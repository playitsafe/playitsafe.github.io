[{"title":"A Peek at useRequest hook","url":"/2022/07/30/A-Peek-at-useRequest-hook/","content":"Introduction\nuseRequest is a powerful, well-encapsulated hook from a hook library ahooks to manage async data fetching. When there is multiple async logic in a single component in React, we will deal with a bunch of useState and useEffect hooks, which makes it complicated to call APIs.\nWhat it probably looks like:\n// Component.ts\nconst [ data, setData ] = useState&lt;object&gt;(defaultData)\nconst [ isLoading, setIsloading ] = useState&lt;boolean&gt;(false)\n\nuseEffect(() =&gt; &#123;\n    setIsloading(true)\n  request = service.fetchData(...)\n  setData(...)\n  handlerError(...)\n    setIsloading(false)\n&#125;, [])\n\nWith the help of useRequest, we can simplify our code:\nimport &#123; useRequest &#125; from &#39;ahooks&#39;\n\nconst &#123; data, run: request, loading, error &#125; = useRequest(service.serviceA, options)\n\nMain features\nuseRequest  provides sufficient enough functionalities for network request scenarios in React projects including:\n\nAutomatic&#x2F;manual request\nPolling\nDebounce\nThrottling\nRefresh on window focus\nError retry\nLoading delay\nSWR(stale-while-revalidate)\nCaching\n\nA Glance on Basic Usage\nLoading delaySet the delay time for loading to become true\nconst &#123; loading, data &#125; = useRequest(getUsername, &#123;\n  loadingDelay: 300 //Set the delay time for loading to become true\n&#125;);\n\nreturn &lt;div&gt;&#123; loading ? &#39;Loading...&#39; : data &#125;&lt;/div&gt;\n\nPollingBy setting options.pollingInterval , enter the polling mode, useRequest  will periodically trigger service execution.\nconst &#123; data, run, cancel &#125; = useRequest(getUsername, &#123;\n  pollingInterval: 3000,//will periodically trigger service execution.\n&#125;);\n\nRefresh on window focusthe request will be refreshed when the browser is refocus  and revisible.\nconst &#123; data &#125; = useRequest(getUsername, &#123;\n  refreshOnWindowFocus: true,\n&#125;);\n\nDebounce &amp; ThrottlingEnter the debounce mode by setting options.debounceWait &#x2F; options.throttleWait. At this time, if run or runAsync is triggered frequently, the request will be executed with the debounce&#x2F;throttle strategy.\nconst &#123; data, run &#125; = useRequest(getUsername, &#123;\n  debounceWait: 300,\n    throttleWait: 300,\n  manual: true\n&#125;);\n\nCache &amp; SWRIf options.cacheKey  is set, useRequest  will cache the successful data . The next time the component is initialized, if there is cached data, it will return the cached data first, and then send a new request in background, which is the ability of SWR.\nasync function getArticle(): Promise&lt;&#123; data: string; time: number &#125;&gt; &#123;\n  console.log(&#39;cacheKey&#39;);\n  return new Promise((resolve) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n      resolve(&#123;\n        data: Mock.mock(&#39;@paragraph&#39;),\n        time: new Date().getTime(),\n      &#125;);\n    &#125;, 1000);\n  &#125;);\n&#125;\n\nconst Article = () =&gt; &#123;\n  const &#123; data, loading &#125; = useRequest(getArticle, &#123;\n    cacheKey: &#39;cacheKey-demo&#39;,\n  &#125;);\n  if (!data &amp;&amp; loading) &#123;\n    return &lt;p&gt;Loading&lt;/p&gt;;\n  &#125;\n    return (\n    &lt;&gt;\n      &lt;p&gt;Background loading: &#123;loading ? &#39;true&#39; : &#39;false&#39;&#125;&lt;/p&gt;\n      &lt;p&gt;Latest request time: &#123;data?.time&#125;&lt;/p&gt;\n      &lt;p&gt;&#123;data?.data&#125;&lt;/p&gt;\n    &lt;/&gt;\n  );\n&#125;\n\nError retryBy setting options.retryCount , set the number of error retries, useRequest will retry after it fails.\nconst &#123; data, run &#125; = useRequest(getUsername, &#123;\n  retryCount: 3,\n&#125;);\n\nDesign PatternuseRequest has two main modules that work together to serve its functionality: the main Fetch class and plugins\nThe Plugin module uses varieties of different plugins, each of which only works for a specific function.\nFetch module on the other hand is even more simple - to implement the Fetch class which aggregates all plugins to this hook to make it robust and easy to maintain.\n\nSource code\nFetch - the coreStructure of Fetch class:\nexport default class Fetch&lt;TData, TParams extends any[]&gt; &#123;\n  pluginImpls: PluginReturn&lt;TData, TParams&gt;[];\n\n  count: number = 0;\n\n  state: FetchState&lt;TData, TParams&gt; = &#123;\n    loading: false,\n    params: undefined,\n    data: undefined,\n    error: undefined,\n  &#125;;\n\n  constructor(\n    public serviceRef: MutableRefObject&lt;Service&lt;TData, TParams&gt;&gt;,\n    public options: Options&lt;TData, TParams&gt;,\n    public subscribe: Subscribe,\n    public initState: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;,\n  ) &#123;\n    this.state = &#123;\n      ...this.state,\n      loading: !options.manual,\n      ...initState,\n    &#125;;\n  &#125;\n\n  setState(s: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;) &#123;...&#125;\n\n  runPluginHandler(event: keyof PluginReturn&lt;TData, TParams&gt;, ...rest: any[]) &#123;...&#125;\n\n  async runAsync(...params: TParams): Promise&lt;TData&gt; &#123;...&#125;\n\n  run(...params: TParams) &#123;...&#125;\n\n  cancel() &#123;...&#125;\n\n  refresh() &#123;...&#125;\n\n  refreshAsync() &#123;...&#125;\n\n  mutate(data?: TData | ((oldData?: TData) =&gt; TData | undefined)) &#123;...&#125;\n\nMost of its API is provided for the user to call such as run、runAsync、cancel、refresh、refreshAsync、mutate, while runPluginHandler、setState are for internal use.\npluginImplsAs per its properties, we can see it has a pluginImpls property, from its type PluginReturn&lt;TData, TParams&gt;[] it seems to contain results of all plugins after execution.\nexport interface PluginReturn&lt;TData, TParams extends any[]&gt; &#123;\n  onBefore?: (params: TParams) =&gt;\n    | (&#123;\n        stopNow?: boolean;\n        returnNow?: boolean;\n      &#125; &amp; Partial&lt;FetchState&lt;TData, TParams&gt;&gt;)\n    | void;\n\n  onRequest?: (\n    service: Service&lt;TData, TParams&gt;,\n    params: TParams,\n  ) =&gt; &#123;\n    servicePromise?: Promise&lt;TData&gt;;\n  &#125;;\n\n  onSuccess?: (data: TData, params: TParams) =&gt; void;\n  onError?: (e: Error, params: TParams) =&gt; void;\n  onFinally?: (params: TParams, data?: TData, e?: Error) =&gt; void;\n  onCancel?: () =&gt; void;\n  onMutate?: (data: TData) =&gt; void;\n&#125;\n\nInside the PluginReturn&lt;TData, TParams&gt; type, it stores some lifecycle callback hooks which will be called at a certain phase of the request.\nstateThere’s also a state property of FetchState&lt;TData, TParams&gt; type. The type definition below shows it stores the context of the request. loading ,data, errors are the results we’d like to get from useRequest\nexport interface FetchState&lt;TData, TParams extends any[]&gt; &#123;\n  loading: boolean;\n  params?: TParams;\n  data?: TData;\n  error?: Error;\n&#125;\n\nconst &#123; data, error, loading &#125; = useRequest(service);\n\nAnd the setState  API is used to update the state.\nTwo main APIs of the Fetch class are runPluginHandler and runAsync , which are called by all of the other APIs to do some extra work.\nrunPluginHandlerrunPluginHandler(event: keyof PluginReturn&lt;TData, TParams&gt;, ...rest: any[]) &#123;\n    // @ts-ignore\n  const r = this.pluginImpls.map((i) =&gt; i[event]?.(...rest)).filter(Boolean);\n  return Object.assign(&#123;&#125;, ...r);\n&#125;\n\nThis function accepts an event parameter which is of the union type onBefore | onRequest | onSuccess | onError | onFinally | onCancel | onMutate  and other extra parameters. What this handler does is to call the relevant lifecycle hook from pluginImpls and return its result.\nrunAsyncasync runAsync(...params: TParams): Promise&lt;TData&gt; &#123;\n    this.count += 1;\n    const currentCount = this.count;\n\n    const &#123;\n      stopNow = false,\n      returnNow = false,\n      ...state\n    &#125; = this.runPluginHandler(&#39;onBefore&#39;, params);\n\n    // stop request\n    if (stopNow) &#123;\n      return new Promise(() =&gt; &#123;&#125;);\n    &#125;\n\n    this.setState(&#123;\n      loading: true,\n      params,\n      ...state,\n    &#125;);\n\n    // return now\n    if (returnNow) &#123;\n      return Promise.resolve(state.data);\n    &#125;\n\n    this.options.onBefore?.(params);\n\n    try &#123;\n      // replace service\n      let &#123; servicePromise &#125; = this.runPluginHandler(&#39;onRequest&#39;, this.serviceRef.current, params);\n\n      if (!servicePromise) &#123;\n        servicePromise = this.serviceRef.current(...params);\n      &#125;\n\n      const res = await servicePromise;\n\n      if (currentCount !== this.count) &#123;\n        // prevent run.then when request is canceled\n        return new Promise(() =&gt; &#123;&#125;);\n      &#125;\n\n      // const formattedResult = this.options.formatResultRef.current ? this.options.formatResultRef.current(res) : res;\n\n      this.setState(&#123;\n        data: res,\n        error: undefined,\n        loading: false,\n      &#125;);\n\n      this.options.onSuccess?.(res, params);\n      this.runPluginHandler(&#39;onSuccess&#39;, res, params);\n\n      this.options.onFinally?.(params, res, undefined);\n\n      if (currentCount === this.count) &#123;\n        this.runPluginHandler(&#39;onFinally&#39;, params, res, undefined);\n      &#125;\n\n      return res;\n    &#125; catch (error) &#123;\n      if (currentCount !== this.count) &#123;\n        // prevent run.then when request is canceled\n        return new Promise(() =&gt; &#123;&#125;);\n      &#125;\n\n      this.setState(&#123;\n        error,\n        loading: false,\n      &#125;);\n\n      this.options.onError?.(error, params);\n      this.runPluginHandler(&#39;onError&#39;, error, params);\n\n      this.options.onFinally?.(params, undefined, error);\n\n      if (currentCount === this.count) &#123;\n        this.runPluginHandler(&#39;onFinally&#39;, params, undefined, error);\n      &#125;\n\n      throw error;\n    &#125;\n  &#125;\n\nWhat this long function does is to implement callbacks that are passed in to give users the opportunity to process the result of the request instead of handling it automatically. \nFor example, In an onBefore hook, user can cancel a request before it’s been sent out ; In an onRequest hook, the function to fetch data can be overwritten, etc.\nOther APIsOther APIs such as run、cancel、refresh will eventually call runPluginHandler and runAsync .\nThe main responsibility of this Fetch class is to run callbacks in different phases of a request lifecycle and update the state.\nPluginsThe implementation of useRequest separates the core logic and the complicity of each different functionality by the plugin mechanism. Fetch only care about when to call those plugin hooks and each plugin itself will only focus on customizing and  doing its own logic.\nTake usePollingPlugin as an example, the main logic of this plugin is to set a timeout in onFinally callback after each request using pollingInterval passed by users and run refresh function of the Fetch instance.\nconst usePollingPlugin: Plugin&lt;any, any[]&gt; = (\n  fetchInstance,\n  &#123; pollingInterval, pollingWhenHidden = true &#125;,\n) =&gt; &#123;\n  const timerRef = useRef&lt;NodeJS.Timeout&gt;();\n  const unsubscribeRef = useRef&lt;() =&gt; void&gt;();\n\n  const stopPolling = () =&gt; &#123;\n    if (timerRef.current) &#123;\n      clearTimeout(timerRef.current);\n    &#125;\n    unsubscribeRef.current?.();\n  &#125;;\n\n  useUpdateEffect(() =&gt; &#123;\n    if (!pollingInterval) &#123;\n      stopPolling();\n    &#125;\n  &#125;, [pollingInterval]);\n\n  if (!pollingInterval) &#123;\n    return &#123;&#125;;\n  &#125;\n\n  return &#123;\n    onBefore: () =&gt; &#123;\n      stopPolling();\n    &#125;,\n    onFinally: () =&gt; &#123;\n      // if pollingWhenHidden = false &amp;&amp; document is hidden, then stop polling and subscribe revisible\n      if (!pollingWhenHidden &amp;&amp; !isDocumentVisible()) &#123;\n        unsubscribeRef.current = subscribeReVisible(() =&gt; &#123;\n          fetchInstance.refresh();\n        &#125;);\n        return;\n      &#125;\n\n      timerRef.current = setTimeout(() =&gt; &#123;\n        fetchInstance.refresh();\n      &#125;, pollingInterval);\n    &#125;,\n    onCancel: () =&gt; &#123;\n      stopPolling();\n    &#125;,\n  &#125;;\n&#125;;\n\nAdding upTo hook up the core Fetch class and plugins together to make this hook work, useRequestImplement is called and accepts request options and plugins from a higher level and Fetch will be instantiated inside the function.\nfunction useRequestImplement&lt;TData, TParams extends any[]&gt;(\n  service: Service&lt;TData, TParams&gt;,\n  options: Options&lt;TData, TParams&gt; = &#123;&#125;,\n  plugins: Plugin&lt;TData, TParams&gt;[] = [],\n) &#123;\n  const &#123; manual = false, ...rest &#125; = options;\n\n  const fetchOptions = &#123;\n    manual,\n    ...rest,\n  &#125;;\n\n  const serviceRef = useLatest(service);\n\n  const update = useUpdate();\n\n  const fetchInstance = useCreation(() =&gt; &#123;\n    const initState = plugins.map((p) =&gt; p?.onInit?.(fetchOptions)).filter(Boolean);\n\n    return new Fetch&lt;TData, TParams&gt;(\n      serviceRef,\n      fetchOptions,\n      update,\n      Object.assign(&#123;&#125;, ...initState),\n    );\n  &#125;, []);\n  fetchInstance.options = fetchOptions;\n  // run all plugins hooks\n  fetchInstance.pluginImpls = plugins.map((p) =&gt; p(fetchInstance, fetchOptions));\n\n  useMount(() =&gt; &#123;\n    if (!manual) &#123;\n      // useCachePlugin can set fetchInstance.state.params from cache when init\n      const params = fetchInstance.state.params || options.defaultParams || [];\n      // @ts-ignore\n      fetchInstance.run(...params);\n    &#125;\n  &#125;);\n\n  useUnmount(() =&gt; &#123;\n    fetchInstance.cancel();\n  &#125;);\n\n  return &#123;\n    loading: fetchInstance.state.loading,\n    data: fetchInstance.state.data,\n    error: fetchInstance.state.error,\n    params: fetchInstance.state.params || [],\n    cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)),\n    refresh: useMemoizedFn(fetchInstance.refresh.bind(fetchInstance)),\n    refreshAsync: useMemoizedFn(fetchInstance.refreshAsync.bind(fetchInstance)),\n    run: useMemoizedFn(fetchInstance.run.bind(fetchInstance)),\n    runAsync: useMemoizedFn(fetchInstance.runAsync.bind(fetchInstance)),\n    mutate: useMemoizedFn(fetchInstance.mutate.bind(fetchInstance)),\n  &#125; as Result&lt;TData, TParams&gt;;\n&#125;\n\nexport default useRequestImplement;\n\nFinally, this function will be returned in a useRequest function with custom plugins along with its native plugins passed in.\nfunction useRequest&lt;TData, TParams extends any[]&gt;(\n  service: Service&lt;TData, TParams&gt;,\n  options?: Options&lt;TData, TParams&gt;,\n  plugins?: Plugin&lt;TData, TParams&gt;[],\n) &#123;\n  return useRequestImplement&lt;TData, TParams&gt;(service, options, [\n    ...(plugins || []),\n    useDebouncePlugin,\n    useLoadingDelayPlugin,\n    usePollingPlugin,\n    useRefreshOnWindowFocusPlugin,\n    useThrottlePlugin,\n    useRefreshDeps,\n    useCachePlugin,\n    useRetryPlugin,\n    useReadyPlugin,\n  ] as Plugin&lt;TData, TParams&gt;[]);\n&#125;\n\nSummariseThe main idea of implementing a plugin is to find out the appropriate phase of the request lifecycle and plug in the core logic of the hook. The most important takeaway from the exploration of the hook’s source code is the approach of separating its core Fetch function and its plugins, which makes it more reusable and maintainable. Users are able to extend the plugins easily as they wish and each of the plugins works independently. I believe it’s a great example of the single responsibility principle and that’s something I could borrow from when customizing a hook or implementing complicated logic.\nReferencehttps://ahooks.js.org/hooks/use-request/basichttps://github.com/alibaba/hooks/tree/master/packages/hooks/src/useRequest/srchttps://qdmana.com/2022/02/202202020201538966.html\n","categories":["Front-end"],"tags":["Hooks","React","Web"]},{"title":"Challenge accepted - Typescript challenge series(1)","url":"/2022/08/06/Challenge-accepted-Typescript-challenge-series-1/","content":"\nPrefixI found a repo on Github about Typescript not long ago which provides a bunch of exercises which helps us to understand the fundamental of Typescript. As most of projects nowadays are using Typescript to implement static typing, I decided to follow along and see how I’ll go with those challenges.\nHow to play around with it?There are questions of different levels in the questions directory, each of which has a README, test-cases and template. The challenge is to modify the type in template to make test cases all pass in test-cases .\nLet’s get started from the easy ones!\n00004 Easy PickImplement the built-in Pick&lt;T, K&gt; generic without using it.\nConstructs a type by picking the set of properties K from T\nFor example:\ninterface Todo &#123;\n  title: string\n  description: string\n  completed: boolean\n&#125;\n\ntype TodoPreview = MyPick&lt;Todo, &#39;title&#39; | &#39;completed&#39;&gt;\n\nconst todo: TodoPreview = &#123;\n    title: &#39;Clean room&#39;,\n    completed: false,\n&#125;\n\nTestsimport type &#123; Equal, Expect &#125; from &#39;@type-challenges/utils&#39;\n\ntype cases = [\n  Expect&lt;Equal&lt;Expected1, MyPick&lt;Todo, &#39;title&#39;&gt;&gt;&gt;,\n  Expect&lt;Equal&lt;Expected2, MyPick&lt;Todo, &#39;title&#39; | &#39;completed&#39;&gt;&gt;&gt;,\n  // @ts-expect-error\n  MyPick&lt;Todo, &#39;title&#39; | &#39;completed&#39; | &#39;invalid&#39;&gt;,\n]\n\ninterface Todo &#123;\n  title: string\n  description: string\n  completed: boolean\n&#125;\n\ninterface Expected1 &#123;\n  title: string\n&#125;\n\ninterface Expected2 &#123;\n  title: string\n  completed: boolean\n&#125;\n\nSolutiontype MyPick should work as the same as the native Pick type in Typescript, which will generated a new type the the picked property keys from the given type&#x2F;interface with same value type of the picked key. See Pick in Typescript docs here: https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys\nFirst of all, we need to ensure the second generic type will extend T‘s properties:\ntype MyPick&lt;T, KEYS extends keyof T&gt; = &#123;&#125;\n\nThen, we can use mapped types to specify all key types of KEYS, and use indexed access type to specify the value type:\ntype MyPick&lt;T, KEYS extends keyof T&gt; = &#123;\n  [K in KEYS]: T[K]\n&#125;\n\nAt this stage, all test cases should pass with no complaining errors.\n00007 Easy ReadonlyImplement the built-in Readonly&lt;T&gt; generic without using it.\nConstructs a type with all properties of T set to readonly, meaning the properties of the constructed type cannot be reassigned.\nFor example:\ninterface Todo &#123;\n  title: string\n  description: string\n&#125;\n\nconst todo: MyReadonly&lt;Todo&gt; = &#123;\n  title: &quot;Hey&quot;,\n  description: &quot;foobar&quot;\n&#125;\n\ntodo.title = &quot;Hello&quot; // Error: cannot reassign a readonly property\ntodo.description = &quot;barFoo&quot; // Error: cannot reassign a readonly property\n\nTestsimport type &#123; Equal, Expect &#125; from &#39;@type-challenges/utils&#39;\n\ntype cases = [\n  Expect&lt;Equal&lt;MyReadonly&lt;Todo1&gt;, Readonly&lt;Todo1&gt;&gt;&gt;,\n]\n\ninterface Todo1 &#123;\n  title: string\n  description: string\n  completed: boolean\n  meta: &#123;\n    author: string\n  &#125;\n&#125;\n\nSolutionThis is a simple one. The solution is to use mapped type to iterate through Todo and add readonly to each of its keys.\ntype MyReadonly&lt;T&gt; = &#123;\n  readonly [KEY in keyof T]: T[KEY]\n&#125;\n\nThis shall make its tests all pass.\n00011 Easy TupleGive an array, transform into an object type and the key&#x2F;value must in the given array.\nFor example:\nconst tuple = [&#39;tesla&#39;, &#39;model 3&#39;, &#39;model X&#39;, &#39;model Y&#39;] as const\n\ntype result = TupleToObject&lt;typeof tuple&gt; // expected &#123; tesla: &#39;tesla&#39;, &#39;model 3&#39;: &#39;model 3&#39;, &#39;model X&#39;: &#39;model X&#39;, &#39;model Y&#39;: &#39;model Y&#39;&#125;\n\nTestsimport type &#123; Equal, Expect &#125; from &#39;@type-challenges/utils&#39;\n\nconst tuple = [&#39;tesla&#39;, &#39;model 3&#39;, &#39;model X&#39;, &#39;model Y&#39;] as const\nconst tupleNumber = [1, 2, 3, 4] as const\nconst tupleMix = [1, &#39;2&#39;, 3, &#39;4&#39;] as const\n\ntype cases = [\n  Expect&lt;Equal&lt;TupleToObject&lt;typeof tuple&gt;, &#123; tesla: &#39;tesla&#39;; &#39;model 3&#39;: &#39;model 3&#39;; &#39;model X&#39;: &#39;model X&#39;; &#39;model Y&#39;: &#39;model Y&#39; &#125;&gt;&gt;,\n  Expect&lt;Equal&lt;TupleToObject&lt;typeof tupleNumber&gt;, &#123; 1: 1; 2: 2; 3: 3; 4: 4 &#125;&gt;&gt;,\n  Expect&lt;Equal&lt;TupleToObject&lt;typeof tupleMix&gt;, &#123; 1: 1; &#39;2&#39;: &#39;2&#39;; 3: 3; &#39;4&#39;: &#39;4&#39; &#125;&gt;&gt;,\n]\n\n// @ts-expect-errorr\ntype error = TupleToObject&lt;[[1, 2], &#123;&#125;]&gt;\n\nSolutionFirst we need to ensure that this type accepts const arrays(tuples):\ntype TupleToObject&lt;T extends readonly any[]&gt; = any\n\nNext, we want to get all of the value inside of it as a union type to iterate through the tuple just like we use mapped type to iterate through an object type.In array&#x2F;tuple, we cannot use keypf T operator, instead we can treat array as an object-like type that has number as key of each of its element - we can do T[number] to get all of its values. So it’s going to be like this:\ntype TupleToObject&lt;T extends readonly any[]&gt; = &#123;\n  [VAL in T[number]]: VAL\n&#125;\n\nTill now we solve most of the test cases, except for the error handling case:\ntype error = TupleToObject&lt;[[1, 2], &#123;&#125;]&gt;\n\nWe can see it doesn’t like empty object or array&#x2F;tuple element to be inside. So the  simplest way is to use extends to constrain the type to be number or string\ntype TupleToObject&lt;T extends readonly (number | string)[]&gt; = &#123;\n  [VAL in T[number]]: VAL\n&#125;\n\nNo it’s all good!\n00014 Easy First of ArrayImplement a generic First&lt;T&gt; that takes an Array T and returns it’s first element’s type.For example:\ntype arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\ntype arr2 = [3, 2, 1]\n\ntype head1 = First&lt;arr1&gt; // expected to be &#39;a&#39;\ntype head2 = First&lt;arr2&gt; // expected to be 3\n\nTestsimport type &#123; Equal, Expect &#125; from &#39;@type-challenges/utils&#39;\n\ntype cases = [\n  Expect&lt;Equal&lt;First&lt;[3, 2, 1]&gt;, 3&gt;&gt;,\n  Expect&lt;Equal&lt;First&lt;[() =&gt; 123, &#123; a: string &#125;]&gt;, () =&gt; 123&gt;&gt;,\n  Expect&lt;Equal&lt;First&lt;[]&gt;, never&gt;&gt;,\n  Expect&lt;Equal&lt;First&lt;[undefined]&gt;, undefined&gt;&gt;,\n]\n\ntype errors = [\n  // @ts-expect-error\n  First&lt;&#39;notArray&#39;&gt;,\n  // @ts-expect-error\n  First&lt;&#123; 0: &#39;arrayLike&#39; &#125;&gt;,\n]\n\nSolution 1Our first thought was like this:\ntype First&lt;T extends any[]&gt; = T[0]\n\nThis will solve most of test cases, but failed when T is an empty array. So we can add a conditional return:\ntype First&lt;T extends any[]&gt; = T extends [] ? never : T[0]\n\nSolution 2Instead of checking T extends [], we can check its length type. From previous tests we know there’s a length property on array&#x2F;tuple type, so we can do:\ntype First&lt;T extends any[]&gt; = T[&#39;length&#39;] extends 0 ? never : T[0]\n\nSolution 3We can also check if T[0] is in array:\ntype First&lt;T extends any[]&gt; = T[0] extends T[number] ? T[0] : never\n\nSolution 4We can also use infer to get the type of the first element of the array:\ntype First&lt;T extends any[]&gt; = T extends [infer FIRST, ...infer REST] ? FIRST : never\n\n00018 Easy Tuple LengthCreate a generic Length, pick the length of the tuple.\nFor example:\ntype tesla = [&#39;tesla&#39;, &#39;model 3&#39;, &#39;model X&#39;, &#39;model Y&#39;]\ntype spaceX = [&#39;FALCON 9&#39;, &#39;FALCON HEAVY&#39;, &#39;DRAGON&#39;, &#39;STARSHIP&#39;, &#39;HUMAN SPACEFLIGHT&#39;]\n\ntype teslaLength = Length&lt;tesla&gt;  // expected 4\ntype spaceXLength = Length&lt;spaceX&gt; // expected 5\n\nTestsimport type &#123; Equal, Expect &#125; from &#39;@type-challenges/utils&#39;\n\nconst tesla = [&#39;tesla&#39;, &#39;model 3&#39;, &#39;model X&#39;, &#39;model Y&#39;] as const\nconst spaceX = [&#39;FALCON 9&#39;, &#39;FALCON HEAVY&#39;, &#39;DRAGON&#39;, &#39;STARSHIP&#39;, &#39;HUMAN SPACEFLIGHT&#39;] as const\n\ntype cases = [\n  Expect&lt;Equal&lt;Length&lt;typeof tesla&gt;, 4&gt;&gt;,\n  Expect&lt;Equal&lt;Length&lt;typeof spaceX&gt;, 5&gt;&gt;,\n  // @ts-expect-error\n  Length&lt;5&gt;,\n  // @ts-expect-error\n  Length&lt;&#39;hello world&#39;&gt;,\n]\n\nSolutionThis is an easy one. From the examples and tests we can see Length accepts constant tuple. and we can use length property of array&#x2F;tuple type to get the length. So it’ll be like this:\ntype Length&lt;T extends readonly any[]&gt; = T[&#39;length&#39;]\n\nSummary👉 keyof T OperatorTo get all keys as a union type from a type or interface, we can use mapped types in.\ntype Point = &#123; x: number; y: number &#125;;\ntype P = keyof Point;\n\n// P is the same type as “x” | “y”\n\nMore on this: https://www.typescriptlang.org/docs/handbook/2/keyof-types.html#handbook-content\n👉 [KEY in KTYPES]A mapped type is a generic type which uses a union of PropertyKeys (frequently created via a keyof) to iterate through keys to create a type.\nMore on this:https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#handbook-content\n👉 TODO[KEY]Indexed access type. We can use an indexed access type to look up a specific property on another type:\ntype Person = &#123; age: number; name: string; alive: boolean &#125;;\ntype Age = Person[&quot;age&quot;];\n\n// type Age = number\n\nIndexed access type can also get the length of an array as a type.\nconst arr = [1, 3, 4]\ntype TLength = arr[&#39;length&#39;]\n\nMore on this: https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html#handbook-content\n👉 extendsThe keyword extends stands for constraints when defining a generic type.\n👉 Native ReadOnly type will do as the following:\n interface Todo &#123;\n   title: string\n   description: string\n &#125;\n \n const todo: Readonly&lt;Todo&gt; = &#123;\n   title: &quot;Hey&quot;,\n   description: &quot;foobar&quot;\n &#125;\n\n // will make `todo` as a readonly object:\n  const todo: &lt;Todo&gt; = &#123;\n   readonly title: &quot;Hey&quot;,\n   readonly description: &quot;foobar&quot;\n &#125;\n\n More on ReadOnly: https://www.tutorialsteacher.com/typescript/typescript-readonly\n👉 as const operatorconst tuple = [&#39;tesla&#39;, &#39;model 3&#39;] as const\n\n// will be equivalent to \n\ntypeof tuple = readonly [&#39;tesla&#39;, &#39;model 3&#39;]`\n\n👉 To get all values from an array type:We can do ARR[number] to get all values as an union type of the array type ARR and use E in ARR[number] to iterate through.\n👉 To get type of the first element in an arrayT[0]\n👉 Get length of an arrayT[&#39;length&#39;] &#x2F;&#x2F;also known as indexed\n👉 extends union typeIf we check if a extends a|2|3, will check every type in union type to see if they match.\n👉 infer in array destructionT extends [infer FIRST, ...infer REST] ? FIRST : never\n\nif FIRST can be successfully destructed, then return FIRST\nconst arr: any[] = []\nconst [a, ...b] = arr\n\na ==&gt; undefined\nb ==&gt; []\n\nTo be continued…\n","categories":["Front-end"],"tags":["Typescript","Javascript"]},{"title":"Challenge accepted - Typescript challenge series(2)","url":"/2022/08/13/Challenge-accepted-Typescript-challenge-series-2/","content":"\n00043 Easy ExcludeImplement the built-in Exclude&lt;T, U&gt;\ntype Result = MyExclude&lt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39;, &#39;a&#39;&gt;\n// &#39;b&#39; | &#39;c&#39;\n\nTestsimport type &#123; Equal, Expect &#125; from &#39;@type-challenges/utils&#39;\n\ntype cases = [\n  Expect&lt;Equal&lt;MyExclude&lt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39;, &#39;a&#39;&gt;, &#39;b&#39; | &#39;c&#39;&gt;&gt;,\n  Expect&lt;Equal&lt;MyExclude&lt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39;, &#39;a&#39; | &#39;b&#39;&gt;, &#39;c&#39;&gt;&gt;,\n  Expect&lt;Equal&lt;MyExclude&lt;string | number | (() =&gt; void), Function&gt;, string | number&gt;&gt;,\n]\n\nSolutionWhen both sides of extends are union types, extends will iterate through each type inside to check.\ntype MyExclude&lt;T, U&gt; = T extends U ? never : T\n\nSummary👉 T extends UUnion type will iterate through each union type to check if every type in T exists in a type in U. It works like a for loop in javascript. And it will return the result as a union type as well.\n00533 Easy ConcatImplement the JavaScript Array.concat function in the type system. A type takes the two arguments. The output should be a new array that includes inputs in ltr order.\nFor example:\ntype Result = Concat&lt;[1], [2]&gt; // expected to be [1, 2]\n\nTeststype cases = [\n  Expect&lt;Equal&lt;Concat&lt;[], []&gt;, []&gt;&gt;,\n  Expect&lt;Equal&lt;Concat&lt;[], [1]&gt;, [1]&gt;&gt;,\n  Expect&lt;Equal&lt;Concat&lt;[1, 2], [3, 4]&gt;, [1, 2, 3, 4]&gt;&gt;,\n  Expect&lt;Equal&lt;Concat&lt;[&#39;1&#39;, 2, &#39;3&#39;], [false, boolean, &#39;4&#39;]&gt;, [&#39;1&#39;, 2, &#39;3&#39;, false, boolean, &#39;4&#39;]&gt;&gt;,\n]\n\nSolutionThis one can be easily done by using spread operator:\ntype Concat&lt;T extends any[], U extends any[]&gt; = [...T, ...U]\n\nSummary👉 Spread operator ...Spread operator can also be used in Typescript.\n00189 Easy AwaitedWe need to get a type which is inside the wrapped type.\ntype ExampleType = Promise&lt;string&gt;\n\ntype Result = MyAwaited&lt;ExampleType&gt; // string\n\nTestsimport type &#123; Equal, Expect &#125; from &#39;@type-challenges/utils&#39;\n\ntype X = Promise&lt;string&gt;\ntype Y = Promise&lt;&#123; field: number &#125;&gt;\ntype Z = Promise&lt;Promise&lt;string | number&gt;&gt;\ntype Z1 = Promise&lt;Promise&lt;Promise&lt;string | boolean&gt;&gt;&gt;\n\ntype cases = [\n  Expect&lt;Equal&lt;MyAwaited&lt;X&gt;, string&gt;&gt;,\n  Expect&lt;Equal&lt;MyAwaited&lt;Y&gt;, &#123; field: number &#125;&gt;&gt;,\n  Expect&lt;Equal&lt;MyAwaited&lt;Z&gt;, string | number&gt;&gt;,\n  Expect&lt;Equal&lt;MyAwaited&lt;Z1&gt;, string | boolean&gt;&gt;,\n]\n\n// @ts-expect-error\ntype error = MyAwaited&lt;number&gt;\n\nSolutionFirst of all, we can see MyAwaited only accepts Promise type as its generic type, so we can do this first:\ntype MyAwaited&lt;T extends Promise&lt;any&gt;&gt; = any\n\nThen, we can use infer to get the type inside the Promise\ntype MyAwaited&lt;T extends Promise&lt;any&gt;&gt; = T extends Promise&lt;infer INSIDE&gt; ? INSIDE : never\n\nAt this stage, we have solved first two of the test cases. Remaining test cases required us to get the type inside the nested Promise type. So we need to check the INSIDE type is a Promise type as well. If so, we can recursively use MyAwaited type.\ntype MyAwaited&lt;T extends Promise&lt;any&gt;&gt; \n    = T extends Promise&lt;infer INSIDE&gt;\n    ? (INSIDE extends Promise&lt;any&gt; ? MyAwaited&lt;INSIDE&gt; : INSIDE)\n    : never\n\nBy using MyAwaited recursively, we can eventually get the type inside.\nSummary👉 infer can only be used in conditional type.More info on \nhttps://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html\nhttps://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#type-inference-in-conditional-types\n","categories":["Front-end"],"tags":["Typescript","Javascript"]},{"title":"Draw a triangle caret with pure CSS","url":"/2022/05/03/Draw-a-triangle-caret-with-pure-css/","content":"Prefix\nIt is very common that we need a triangle caret on a web page to display as an arrow or other similar symbols. It can be achieved by using a png or svg file, or importing from third-party icon library such as Font Awesome\n\nHowever, a more efficient low-carbon way is to draw it using CSS border attribute.\nA normal border\nThe most common use case of a border would be this:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    height: 100px;\n    width: 100px;\n    border: 5px solid #000;\n  &#125;\n&lt;/style&gt;\n\n\nIf we take a look at the border shape by giving a wider width of it, we will see it looks like this:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 200px;\n    height: 200px;\n    border-color: red blue yellow green;\n    border-style: solid;\n    border-width: 50px 50px 50px 50px;\n  &#125;\n&lt;/style&gt;\n\n\nBorder with zero height and width\nInstead of giving height and width to the box, when we set the width and height of the outer box to 0, the width of the border will stretch out the outer box, four sides of the borders will collapse together and each side of the border will be a triangle of 100px wide and 50px height, just like this:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 0;\n    height: 0;\n    border-color: red blue yellow green;\n    border-style: solid;\n    border-width: 50px 50px 50px 50px;\n  &#125;\n&lt;/style&gt;\n\n\nDisplay as a triangle\nNow what we need to do is to hide three other sides of the border and only show one of it:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 0;\n    height: 0;\n    border-color: red transparent transparent transparent;\n    border-style: solid;\n    border-width: 50px 50px 50px 50px;\n  &#125;\n&lt;/style&gt;\n\n\n#Other casesIf we try to set one side of the border width to be zero, we’ll get and rectangle with three triangles:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 0;\n    height: 0;\n    border-color: red blue yellow green;\n    border-style: solid;\n    border-width: 50px 50px 0 50px;\n  &#125;\n&lt;/style&gt;\n\n\nUse casesThis can be useful if we need a ribbon icon on page just like this:\n\nThe solution is to draw a rectangle on top and add a sudo class :after below it to implement 3 sides of the border:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 50px;\n    height: 70px;\n    background: red;\n    position: relative;\n  &#125;\n\n  .box:after &#123;\n    position: absolute;\n    left: 0;\n    top: 70px;\n    content: &#39;&#39;;\n    border-width: 12px 25px;\n    border-style: solid;\n    border-color: green green transparent green;\n  &#125;\n&lt;/style&gt;\n\n\nAnd we just need to set the color all red, and maybe add some text to make it a perfect ribbon.\n\n","categories":["Front-end"],"tags":["Web","CSS"]},{"title":"Implement a countdown timer in React Hooks","url":"/2022/04/02/Implement-a-countdown-timer-in-React-Hooks/","content":"Prefix\nFrom time to time we will see timers in the world of frontend, of which the use cases could be a count-down function, or a disabled button which will be released active after a certain amount of time to force users to read through site T&amp;C, or a button to send mobile code which is restricted to be clickable within a time interval after last click. Many front-end frameworks have already provided an out-of-box component of that such as ProFormCaptcha which to support common CAPTCHA functionality in the middle and backend.\nHowever, we will run into some cases that we need to customize the function as we wish and the provided function from the framework may have limitations. In this case we will need to implement this function by ourself.\nRequirements Analysis\nIdeally, we need to implement a button that behaves like this:\n\nFirst sms will be sent at the time the modal pops up, and the button start to count down util it reaches the time interval.\nAfter each count down, the button will be clickable and will start counting down after each click.\n\n\nImplementation in a React componentBasic setup:\nFrom the perspective of code, will need two states to manage this timer:\n\nA state to record the status of the button(disabled or active).\nA state to record time left after each seconds\n\nSo the basic code structure looks like this:\nimport React, &#123; useEffect, useState &#125; from &#39;react&#39;;\nimport &#123; Input, Button &#125; from &#39;@/my/components&#39;;\n\nconst TIME_INTERVAL = 59;\n\nexport default const TimerModal = () =&gt; &#123;\n    const [seconds, setSeconds] = useState&lt;number&gt;(TIME_INTERVAL);\n    const [isCounting, setIsCounting] = useState&lt;boolean&gt;(false);\n\n    const clickHandler = () =&gt; &#123;\n        sendCode();\n        // reset timer\n    &#125;\n    \n    return (\n        &lt;Input /&gt;\n        &lt;Button onClick=&#123;clickHandler&#125; disabled=&#123;isCounting&#125; /&gt;\n    );\n&#125;\n\nAdd timer logicFrom the requirement above we would know that the TimerModal will pop up and a first SMS has already been sent and the Timer button is disabled and start to count down. In this situation useEffect hook will be a perfect function to host the timer logic.\nuseEffect() dependency listTo listen to the change of the timer button and ensure timer works as we expected, we need to put two of the states(seconds and isCounting) to the dependency list of useEffect. \nInside of the timer logicWe achieve the expected result by updating the seconds(minus 1 in each call) inside a setInterval function. The initial seconds right after the Timer component is mounted is 59s, in the meanwhile, setInterval function inside useEffect hook will update seconds by deducting 1, and this will also trigger useEffect hook again and clear previous setInterval function and start a new session of setInterval() to minus seconds by 1 util it counts down to 1 second, which means the setInterval function is cleared and the countdown session status is reset to inactive(to set isCounting to false and seconds set to initial time interval) and the button will be clickable.\nAfter the button is clicked, the timer will be reset and a new cycle of the useEffect hook will start again.\nimport React, &#123; useEffect, useState &#125; from &#39;react&#39;;\nimport &#123; Input, Button &#125; from &#39;@/my/components&#39;;\n\nconst TIME_INTERVAL = 59;\n\nexport default const TimerModal = () =&gt; &#123;\n    const [seconds, setSeconds] = useState&lt;number&gt;(TIME_INTERVAL);\n    const [isCounting, setIsCounting] = useState&lt;boolean&gt;(true);\n\n    const resetTimer = () =&gt; &#123;\n        setSeconds(TIME_INTERVAL);\n        setIsCounting(true);\n    &#125;\n\n    useEffect((): () =&gt; void =&gt; &#123;\n        //setInterval Type would be number if uses window.setInterval()\n        let interval: null | NodeJS.Timer = null;\n        if (isCounting) &#123;\n            interval = setInterval(() =&gt; &#123;\n                setSeconds(seconds =&gt; &#123;\n                    if (seconds &gt; 1) &#123;\n                        return seconds - 1;\n                    &#125; else &#123;\n                        interval &amp;&amp; clearInterval(interval);\n                        setIsCounting(false);\n                        return TIME_INTERVAL;\n                    &#125;\n                &#125; );\n            &#125;, 1000);\n        &#125; else &#123;\n            interval &amp;&amp; clearInterval(interval);\n        &#125;\n    &#125;, [ isCounting, seconds ])\n\n    const clickHandler = () =&gt; &#123;\n        sendCode();\n        resetTimer();\n    &#125;\n\n    return (\n        &lt;Input /&gt;\n        &lt;Button onClick=&#123;clickHandler&#125; disabled=&#123;isCounting&#125; /&gt;\n    );\n&#125;\n\nReviewThe implementation above seems to perfectly fit the use case, one problem still hides under the hood and will cause memory leakage. If you are on the halfway during countdown session and the Timer component is unmounted(since it’s a modal and will be unmounted after it’s closed), the setInterval function is still there in the background. Luckily, the useEffect hook provides a return callback function to allow us unsubscribe any side effects outside of the React lifecycle, which will be called before the component is unmounted.In this case, we need to return a housekeeping function at the end of the useEffect callback function to clear the setInterval function. So the final code looks like this:\nimport React, &#123; useEffect, useState &#125; from &#39;react&#39;;\nimport &#123; Input, Button &#125; from &#39;@/my/components&#39;;\n\nconst TIME_INTERVAL = 59;\n\nexport default const TimerModal = () =&gt; &#123;\n    const [seconds, setSeconds] = useState&lt;number&gt;(TIME_INTERVAL);\n    const [isCounting, setIsCounting] = useState&lt;boolean&gt;(false);\n\n    const resetTimer = () =&gt; &#123;\n        setSeconds(TIME_INTERVAL);\n        setIsCounting(true);\n    &#125;\n\n    useEffect((): () =&gt; void =&gt; &#123;\n        //setInterval Type would be number if uses window.setInterval()\n        let interval: null | NodeJS.Timer = null;\n        if (isCounting) &#123;\n            interval = setInterval(() =&gt; &#123;\n                setSeconds(seconds =&gt; &#123;\n                    if (seconds &gt; 1) &#123;\n                        return seconds - 1;\n                    &#125; else &#123;\n                        interval &amp;&amp; clearInterval(interval);\n                        setIsCounting(false);\n                        return TIME_INTERVAL;\n                    &#125;\n                &#125; );\n            &#125;, 1000);\n        &#125; else &#123;\n            interval &amp;&amp; clearInterval(interval);\n        &#125;\n        // unsubscription\n        return () =&gt; interval &amp;&amp; clearInterval(interval);\n    &#125;, [ isCounting, seconds ])\n\n    const clickHandler = () =&gt; &#123;\n        sendCode();\n        resetTimer();\n    &#125;\n\n    return (\n        &lt;Input /&gt;\n        &lt;Button onClick=&#123;clickHandler&#125; disabled=&#123;isCounting&#125; /&gt;\n    );\n&#125;\n\nAnother takeaway from this case is that when we update the state which depends on the previous state, we can use a callback function inside useState() hook.the setState() function provided by useState hook accepts either a new state value or a callback function as an updater which returns a new state to set state based on the previous state.\nconst App = () =&gt; &#123;\n  const [num, setNum] = useState(0); // same API as useState\n\n  const handleClick = () =&gt; &#123;\n    setNum(prevState =&gt; prevState + 1);\n  &#125;;\n  return &lt;button onClick=&#123;handleClick&#125;&gt;Increment&lt;/button&gt;;\n&#125;\n\nSummaryThis is a use case that I encountered during development and I think this would be a perfect example to learn and demonstrate the concept of useEffect and useState hooks in React.js. When functional component started to take over class-based component, I firstly use the useEffect hook the way that I use componentDidMount(), componentDidUpdate() and componentDidUnmount() function. After a while, I started to learn that they may share most of the use cases, but the conception is different and useEffect hooks tends to be a much cleaner way to implement and manage a single logic at one place instead of having to use multiple lifecycle functions to trigger&#x2F;subscribe&#x2F;unsubscribe side effects.\nReferencesReact docs: https://reactjs.org/docs/hooks-effect.html\n","categories":["Front-end"],"tags":["Hooks","React","Web"]},{"title":"Deploy A Static Website via AWS S3, CloudFront and More","url":"/2022/06/04/Deploy-A-Website-via-AWS-S3-CloudFront-and-More/","content":"There are many different ways to deploy a website online. A dedicated server with Nginx or Apache, Github Pages and cloud service such as AWS or GCP can all do the trick. However, for a static website, a dedicated server might be a bit overkill as cloud service provides us a cheap, easy and sustainable way to deploy a static website. In this post, I will deploy a commercial website on AWS S3 bucket.\nPrerequisite\nA domain name purchased from domain provider such as Godaddy or AWS Route53.\nA built static website.\n\nArchitectureThe overview of the project architecture will be like this:\n\nCreate an S3 bucketCreate an S3 bucket on AWS and de-select Block Public Access settings to make it accessible by the public.\nAnd then, upload website resources to S3 bucket. Make sure an entry html is included.\nAlso, we’ll need to create a bucket policy to allow PublicReadGetObject permission. Under the permission tab of the bucket, edit bucket policy to add this rule:\n&#123;\n    &quot;Version&quot;: &quot;2012-10-17&quot;,\n    &quot;Statement&quot;: [\n        &#123;\n            &quot;Sid&quot;: &quot;PublicReadGetObject&quot;,\n            &quot;Effect&quot;: &quot;Allow&quot;,\n            &quot;Principal&quot;: &quot;*&quot;,\n            &quot;Action&quot;: &quot;s3:GetObject&quot;,\n            &quot;Resource&quot;: &quot;arn:aws:s3:::myexample.com/*&quot;\n        &#125;\n    ]\n&#125;\n\nRequest an SSL certificate from Amazon Certificate Manager(ACM):To use an ACM certificate with Amazon CloudFront, you must request or import the certificate in the US East (N. Virginia) region.\n\nYou will have CNAME key-value pairs generated for you to verify your domain. If you are using Route53 as a domain provider, simply click Create records in Route53. If you are using other providers such as godaddy, you will need to create these CNAME records so it can be verified.\nCreate a CloudFront distribution\nSelect the bucket for the Origin Domain. If your entry file is in a subfolder, you’ll need to put it in the Origin Path field.\n\nUnder the view settings, you you’d only allow https requests, you can select the Redirect HTTP to HTTPS option.\n\nAdd your domain name as alias in the Alternate domain name field.\n\nSelect the SSL certificate we just requested in the Custom SSL certificate field.\n\nPut your default entry file(ex. index.html) in the Default root object field.\n\n\nOnce the distribution is created and enabled, click into the distribution from console and you’ll get the distribution domain name. You can configure your DNS using this domain name in Route53 or Godaddy.\nI’m using Godaddy so it would be like this:\nRedirect domainIf you want to redirect myexample.com to www.myexample.com which is just configured with CloudFront distribution domain, in Godaddy, you can create a Forwarding rule:\n\nInvalidate CloudFront cacheUnder Invalidation tab, click Create Invalidation and add object path into it:\nSummarizeThis basic deployment with AWS stack includes AWS S3, CloudFront and ACM to enable SSL encryption. What is worth noticing is the S3 bucket policy definition and the region of ACM certificate should be requested in N. Virginia to make it work with CloudFront.\nWhat’s Next?After we deploy the website online, we need to make it visible in search engines which is out of this post’s scope. I’ll be having another post relevant to that in the feature.\nReferencehttps://docs.aws.amazon.com/acm/latest/userguide/acm-regions.html\nhttps://dale-bingham-soteriasoftware.medium.com/creating-a-static-website-using-godaddy-github-aws-s3-codedeploy-and-aws-cloudfront-1990a8f4ddd8\nhttps://tecadmin.net/remove-cloudfront-cache/\n","categories":["DevOps"],"tags":["AWS","S3","CloudFront","ACM"]},{"title":"About Me","url":"/2022/03/12/hello-world/","content":"Welcome to my dev journal! This is your very first post. I’ll be sharing more posts regarding web development on this site in the near future.\nTo know more about me please see here\n"}]