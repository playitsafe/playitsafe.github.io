[{"title":"A Peek at useRequest hook","url":"/2022/07/30/A-Peek-at-useRequest-hook/","content":"Introduction\nuseRequest is a powerful, well-encapsulated hook from a hook library ahooks to manage async data fetching. When there is multiple async logic in a single component in React, we will deal with a bunch of useState and useEffect hooks, which makes it complicated to call APIs.\nWhat it probably looks like:\n// Component.ts\nconst [ data, setData ] = useState&lt;object&gt;(defaultData)\nconst [ isLoading, setIsloading ] = useState&lt;boolean&gt;(false)\n\nuseEffect(() =&gt; &#123;\n    setIsloading(true)\n  request = service.fetchData(...)\n  setData(...)\n  handlerError(...)\n    setIsloading(false)\n&#125;, [])\n\nWith the help of useRequest, we can simplify our code:\nimport &#123; useRequest &#125; from &#39;ahooks&#39;\n\nconst &#123; data, run: request, loading, error &#125; = useRequest(service.serviceA, options)\n\nMain features\nuseRequest  provides sufficient enough functionalities for network request scenarios in React projects including:\n\nAutomatic&#x2F;manual request\nPolling\nDebounce\nThrottling\nRefresh on window focus\nError retry\nLoading delay\nSWR(stale-while-revalidate)\nCaching\n\nA Glance on Basic Usage\nLoading delaySet the delay time for loading to become true\nconst &#123; loading, data &#125; = useRequest(getUsername, &#123;\n  loadingDelay: 300 //Set the delay time for loading to become true\n&#125;);\n\nreturn &lt;div&gt;&#123; loading ? &#39;Loading...&#39; : data &#125;&lt;/div&gt;\n\nPollingBy setting options.pollingInterval , enter the polling mode, useRequest  will periodically trigger service execution.\nconst &#123; data, run, cancel &#125; = useRequest(getUsername, &#123;\n  pollingInterval: 3000,//will periodically trigger service execution.\n&#125;);\n\nRefresh on window focusthe request will be refreshed when the browser is refocus  and revisible.\nconst &#123; data &#125; = useRequest(getUsername, &#123;\n  refreshOnWindowFocus: true,\n&#125;);\n\nDebounce &amp; ThrottlingEnter the debounce mode by setting options.debounceWait &#x2F; options.throttleWait. At this time, if run or runAsync is triggered frequently, the request will be executed with the debounce&#x2F;throttle strategy.\nconst &#123; data, run &#125; = useRequest(getUsername, &#123;\n  debounceWait: 300,\n    throttleWait: 300,\n  manual: true\n&#125;);\n\nCache &amp; SWRIf options.cacheKey  is set, useRequest  will cache the successful data . The next time the component is initialized, if there is cached data, it will return the cached data first, and then send a new request in background, which is the ability of SWR.\nasync function getArticle(): Promise&lt;&#123; data: string; time: number &#125;&gt; &#123;\n  console.log(&#39;cacheKey&#39;);\n  return new Promise((resolve) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n      resolve(&#123;\n        data: Mock.mock(&#39;@paragraph&#39;),\n        time: new Date().getTime(),\n      &#125;);\n    &#125;, 1000);\n  &#125;);\n&#125;\n\nconst Article = () =&gt; &#123;\n  const &#123; data, loading &#125; = useRequest(getArticle, &#123;\n    cacheKey: &#39;cacheKey-demo&#39;,\n  &#125;);\n  if (!data &amp;&amp; loading) &#123;\n    return &lt;p&gt;Loading&lt;/p&gt;;\n  &#125;\n    return (\n    &lt;&gt;\n      &lt;p&gt;Background loading: &#123;loading ? &#39;true&#39; : &#39;false&#39;&#125;&lt;/p&gt;\n      &lt;p&gt;Latest request time: &#123;data?.time&#125;&lt;/p&gt;\n      &lt;p&gt;&#123;data?.data&#125;&lt;/p&gt;\n    &lt;/&gt;\n  );\n&#125;\n\nError retryBy setting options.retryCount , set the number of error retries, useRequest will retry after it fails.\nconst &#123; data, run &#125; = useRequest(getUsername, &#123;\n  retryCount: 3,\n&#125;);\n\nDesign PatternuseRequest has two main modules that work together to serve its functionality: the main Fetch class and plugins\nThe Plugin module uses varieties of different plugins, each of which only works for a specific function.\nFetch module on the other hand is even more simple - to implement the Fetch class which aggregates all plugins to this hook to make it robust and easy to maintain.\n\nSource code\nFetch - the coreStructure of Fetch class:\nexport default class Fetch&lt;TData, TParams extends any[]&gt; &#123;\n  pluginImpls: PluginReturn&lt;TData, TParams&gt;[];\n\n  count: number = 0;\n\n  state: FetchState&lt;TData, TParams&gt; = &#123;\n    loading: false,\n    params: undefined,\n    data: undefined,\n    error: undefined,\n  &#125;;\n\n  constructor(\n    public serviceRef: MutableRefObject&lt;Service&lt;TData, TParams&gt;&gt;,\n    public options: Options&lt;TData, TParams&gt;,\n    public subscribe: Subscribe,\n    public initState: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;,\n  ) &#123;\n    this.state = &#123;\n      ...this.state,\n      loading: !options.manual,\n      ...initState,\n    &#125;;\n  &#125;\n\n  setState(s: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;) &#123;...&#125;\n\n  runPluginHandler(event: keyof PluginReturn&lt;TData, TParams&gt;, ...rest: any[]) &#123;...&#125;\n\n  async runAsync(...params: TParams): Promise&lt;TData&gt; &#123;...&#125;\n\n  run(...params: TParams) &#123;...&#125;\n\n  cancel() &#123;...&#125;\n\n  refresh() &#123;...&#125;\n\n  refreshAsync() &#123;...&#125;\n\n  mutate(data?: TData | ((oldData?: TData) =&gt; TData | undefined)) &#123;...&#125;\n\nMost of its API is provided for the user to call such as run、runAsync、cancel、refresh、refreshAsync、mutate, while runPluginHandler、setState are for internal use.\npluginImplsAs per its properties, we can see it has a pluginImpls property, from its type PluginReturn&lt;TData, TParams&gt;[] it seems to contain results of all plugins after execution.\nexport interface PluginReturn&lt;TData, TParams extends any[]&gt; &#123;\n  onBefore?: (params: TParams) =&gt;\n    | (&#123;\n        stopNow?: boolean;\n        returnNow?: boolean;\n      &#125; &amp; Partial&lt;FetchState&lt;TData, TParams&gt;&gt;)\n    | void;\n\n  onRequest?: (\n    service: Service&lt;TData, TParams&gt;,\n    params: TParams,\n  ) =&gt; &#123;\n    servicePromise?: Promise&lt;TData&gt;;\n  &#125;;\n\n  onSuccess?: (data: TData, params: TParams) =&gt; void;\n  onError?: (e: Error, params: TParams) =&gt; void;\n  onFinally?: (params: TParams, data?: TData, e?: Error) =&gt; void;\n  onCancel?: () =&gt; void;\n  onMutate?: (data: TData) =&gt; void;\n&#125;\n\nInside the PluginReturn&lt;TData, TParams&gt; type, it stores some lifecycle callback hooks which will be called at a certain phase of the request.\nstateThere’s also a state property of FetchState&lt;TData, TParams&gt; type. The type definition below shows it stores the context of the request. loading ,data, errors are the results we’d like to get from useRequest\nexport interface FetchState&lt;TData, TParams extends any[]&gt; &#123;\n  loading: boolean;\n  params?: TParams;\n  data?: TData;\n  error?: Error;\n&#125;\n\nconst &#123; data, error, loading &#125; = useRequest(service);\n\nAnd the setState  API is used to update the state.\nTwo main APIs of the Fetch class are runPluginHandler and runAsync , which are called by all of the other APIs to do some extra work.\nrunPluginHandlerrunPluginHandler(event: keyof PluginReturn&lt;TData, TParams&gt;, ...rest: any[]) &#123;\n    // @ts-ignore\n  const r = this.pluginImpls.map((i) =&gt; i[event]?.(...rest)).filter(Boolean);\n  return Object.assign(&#123;&#125;, ...r);\n&#125;\n\nThis function accepts an event parameter which is of the union type onBefore | onRequest | onSuccess | onError | onFinally | onCancel | onMutate  and other extra parameters. What this handler does is to call the relevant lifecycle hook from pluginImpls and return its result.\nrunAsyncasync runAsync(...params: TParams): Promise&lt;TData&gt; &#123;\n    this.count += 1;\n    const currentCount = this.count;\n\n    const &#123;\n      stopNow = false,\n      returnNow = false,\n      ...state\n    &#125; = this.runPluginHandler(&#39;onBefore&#39;, params);\n\n    // stop request\n    if (stopNow) &#123;\n      return new Promise(() =&gt; &#123;&#125;);\n    &#125;\n\n    this.setState(&#123;\n      loading: true,\n      params,\n      ...state,\n    &#125;);\n\n    // return now\n    if (returnNow) &#123;\n      return Promise.resolve(state.data);\n    &#125;\n\n    this.options.onBefore?.(params);\n\n    try &#123;\n      // replace service\n      let &#123; servicePromise &#125; = this.runPluginHandler(&#39;onRequest&#39;, this.serviceRef.current, params);\n\n      if (!servicePromise) &#123;\n        servicePromise = this.serviceRef.current(...params);\n      &#125;\n\n      const res = await servicePromise;\n\n      if (currentCount !== this.count) &#123;\n        // prevent run.then when request is canceled\n        return new Promise(() =&gt; &#123;&#125;);\n      &#125;\n\n      // const formattedResult = this.options.formatResultRef.current ? this.options.formatResultRef.current(res) : res;\n\n      this.setState(&#123;\n        data: res,\n        error: undefined,\n        loading: false,\n      &#125;);\n\n      this.options.onSuccess?.(res, params);\n      this.runPluginHandler(&#39;onSuccess&#39;, res, params);\n\n      this.options.onFinally?.(params, res, undefined);\n\n      if (currentCount === this.count) &#123;\n        this.runPluginHandler(&#39;onFinally&#39;, params, res, undefined);\n      &#125;\n\n      return res;\n    &#125; catch (error) &#123;\n      if (currentCount !== this.count) &#123;\n        // prevent run.then when request is canceled\n        return new Promise(() =&gt; &#123;&#125;);\n      &#125;\n\n      this.setState(&#123;\n        error,\n        loading: false,\n      &#125;);\n\n      this.options.onError?.(error, params);\n      this.runPluginHandler(&#39;onError&#39;, error, params);\n\n      this.options.onFinally?.(params, undefined, error);\n\n      if (currentCount === this.count) &#123;\n        this.runPluginHandler(&#39;onFinally&#39;, params, undefined, error);\n      &#125;\n\n      throw error;\n    &#125;\n  &#125;\n\nWhat this long function does is to implement callbacks that are passed in to give users the opportunity to process the result of the request instead of handling it automatically. \nFor example, In an onBefore hook, user can cancel a request before it’s been sent out ; In an onRequest hook, the function to fetch data can be overwritten, etc.\nOther APIsOther APIs such as run、cancel、refresh will eventually call runPluginHandler and runAsync .\nThe main responsibility of this Fetch class is to run callbacks in different phases of a request lifecycle and update the state.\nPluginsThe implementation of useRequest separates the core logic and the complicity of each different functionality by the plugin mechanism. Fetch only care about when to call those plugin hooks and each plugin itself will only focus on customizing and  doing its own logic.\nTake usePollingPlugin as an example, the main logic of this plugin is to set a timeout in onFinally callback after each request using pollingInterval passed by users and run refresh function of the Fetch instance.\nconst usePollingPlugin: Plugin&lt;any, any[]&gt; = (\n  fetchInstance,\n  &#123; pollingInterval, pollingWhenHidden = true &#125;,\n) =&gt; &#123;\n  const timerRef = useRef&lt;NodeJS.Timeout&gt;();\n  const unsubscribeRef = useRef&lt;() =&gt; void&gt;();\n\n  const stopPolling = () =&gt; &#123;\n    if (timerRef.current) &#123;\n      clearTimeout(timerRef.current);\n    &#125;\n    unsubscribeRef.current?.();\n  &#125;;\n\n  useUpdateEffect(() =&gt; &#123;\n    if (!pollingInterval) &#123;\n      stopPolling();\n    &#125;\n  &#125;, [pollingInterval]);\n\n  if (!pollingInterval) &#123;\n    return &#123;&#125;;\n  &#125;\n\n  return &#123;\n    onBefore: () =&gt; &#123;\n      stopPolling();\n    &#125;,\n    onFinally: () =&gt; &#123;\n      // if pollingWhenHidden = false &amp;&amp; document is hidden, then stop polling and subscribe revisible\n      if (!pollingWhenHidden &amp;&amp; !isDocumentVisible()) &#123;\n        unsubscribeRef.current = subscribeReVisible(() =&gt; &#123;\n          fetchInstance.refresh();\n        &#125;);\n        return;\n      &#125;\n\n      timerRef.current = setTimeout(() =&gt; &#123;\n        fetchInstance.refresh();\n      &#125;, pollingInterval);\n    &#125;,\n    onCancel: () =&gt; &#123;\n      stopPolling();\n    &#125;,\n  &#125;;\n&#125;;\n\nAdding upTo hook up the core Fetch class and plugins together to make this hook work, useRequestImplement is called and accepts request options and plugins from a higher level and Fetch will be instantiated inside the function.\nfunction useRequestImplement&lt;TData, TParams extends any[]&gt;(\n  service: Service&lt;TData, TParams&gt;,\n  options: Options&lt;TData, TParams&gt; = &#123;&#125;,\n  plugins: Plugin&lt;TData, TParams&gt;[] = [],\n) &#123;\n  const &#123; manual = false, ...rest &#125; = options;\n\n  const fetchOptions = &#123;\n    manual,\n    ...rest,\n  &#125;;\n\n  const serviceRef = useLatest(service);\n\n  const update = useUpdate();\n\n  const fetchInstance = useCreation(() =&gt; &#123;\n    const initState = plugins.map((p) =&gt; p?.onInit?.(fetchOptions)).filter(Boolean);\n\n    return new Fetch&lt;TData, TParams&gt;(\n      serviceRef,\n      fetchOptions,\n      update,\n      Object.assign(&#123;&#125;, ...initState),\n    );\n  &#125;, []);\n  fetchInstance.options = fetchOptions;\n  // run all plugins hooks\n  fetchInstance.pluginImpls = plugins.map((p) =&gt; p(fetchInstance, fetchOptions));\n\n  useMount(() =&gt; &#123;\n    if (!manual) &#123;\n      // useCachePlugin can set fetchInstance.state.params from cache when init\n      const params = fetchInstance.state.params || options.defaultParams || [];\n      // @ts-ignore\n      fetchInstance.run(...params);\n    &#125;\n  &#125;);\n\n  useUnmount(() =&gt; &#123;\n    fetchInstance.cancel();\n  &#125;);\n\n  return &#123;\n    loading: fetchInstance.state.loading,\n    data: fetchInstance.state.data,\n    error: fetchInstance.state.error,\n    params: fetchInstance.state.params || [],\n    cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)),\n    refresh: useMemoizedFn(fetchInstance.refresh.bind(fetchInstance)),\n    refreshAsync: useMemoizedFn(fetchInstance.refreshAsync.bind(fetchInstance)),\n    run: useMemoizedFn(fetchInstance.run.bind(fetchInstance)),\n    runAsync: useMemoizedFn(fetchInstance.runAsync.bind(fetchInstance)),\n    mutate: useMemoizedFn(fetchInstance.mutate.bind(fetchInstance)),\n  &#125; as Result&lt;TData, TParams&gt;;\n&#125;\n\nexport default useRequestImplement;\n\nFinally, this function will be returned in a useRequest function with custom plugins along with its native plugins passed in.\nfunction useRequest&lt;TData, TParams extends any[]&gt;(\n  service: Service&lt;TData, TParams&gt;,\n  options?: Options&lt;TData, TParams&gt;,\n  plugins?: Plugin&lt;TData, TParams&gt;[],\n) &#123;\n  return useRequestImplement&lt;TData, TParams&gt;(service, options, [\n    ...(plugins || []),\n    useDebouncePlugin,\n    useLoadingDelayPlugin,\n    usePollingPlugin,\n    useRefreshOnWindowFocusPlugin,\n    useThrottlePlugin,\n    useRefreshDeps,\n    useCachePlugin,\n    useRetryPlugin,\n    useReadyPlugin,\n  ] as Plugin&lt;TData, TParams&gt;[]);\n&#125;\n\nSummariseThe main idea of implementing a plugin is to find out the appropriate phase of the request lifecycle and plug in the core logic of the hook. The most important takeaway from the exploration of the hook’s source code is the approach of separating its core Fetch function and its plugins, which makes it more reusable and maintainable. Users are able to extend the plugins easily as they wish and each of the plugins works independently. I believe it’s a great example of the single responsibility principle and that’s something I could borrow from when customizing a hook or implementing complicated logic.\nReferencehttps://ahooks.js.org/hooks/use-request/basichttps://github.com/alibaba/hooks/tree/master/packages/hooks/src/useRequest/srchttps://qdmana.com/2022/02/202202020201538966.html\n","categories":["Front-end"],"tags":["Hooks","React","Web"]},{"title":"Deploy A Static Website via AWS S3, CloudFront and More","url":"/2022/06/04/Deploy-A-Website-via-AWS-S3-CloudFront-and-More/","content":"There are many different ways to deploy a website online. A dedicated server with Nginx or Apache, Github Pages and cloud service such as AWS or GCP can all do the trick. However, for a static website, a dedicated server might be a bit overkill as cloud service provides us a cheap, easy and sustainable way to deploy a static website. In this post, I will deploy a commercial website on AWS S3 bucket.\nPrerequisite\nA domain name purchased from domain provider such as Godaddy or AWS Route53.\nA built static website.\n\nArchitectureThe overview of the project architecture will be like this:\n\nCreate an S3 bucketCreate an S3 bucket on AWS and de-select Block Public Access settings to make it accessible by the public.\nAnd then, upload website resources to S3 bucket. Make sure an entry html is included.\nAlso, we’ll need to create a bucket policy to allow PublicReadGetObject permission. Under the permission tab of the bucket, edit bucket policy to add this rule:\n&#123;\n    &quot;Version&quot;: &quot;2012-10-17&quot;,\n    &quot;Statement&quot;: [\n        &#123;\n            &quot;Sid&quot;: &quot;PublicReadGetObject&quot;,\n            &quot;Effect&quot;: &quot;Allow&quot;,\n            &quot;Principal&quot;: &quot;*&quot;,\n            &quot;Action&quot;: &quot;s3:GetObject&quot;,\n            &quot;Resource&quot;: &quot;arn:aws:s3:::myexample.com/*&quot;\n        &#125;\n    ]\n&#125;\n\nRequest an SSL certificate from Amazon Certificate Manager(ACM):To use an ACM certificate with Amazon CloudFront, you must request or import the certificate in the US East (N. Virginia) region.\n\nYou will have CNAME key-value pairs generated for you to verify your domain. If you are using Route53 as a domain provider, simply click Create records in Route53. If you are using other providers such as godaddy, you will need to create these CNAME records so it can be verified.\nCreate a CloudFront distribution\nSelect the bucket for the Origin Domain. If your entry file is in a subfolder, you’ll need to put it in the Origin Path field.\n\nUnder the view settings, you you’d only allow https requests, you can select the Redirect HTTP to HTTPS option.\n\nAdd your domain name as alias in the Alternate domain name field.\n\nSelect the SSL certificate we just requested in the Custom SSL certificate field.\n\nPut your default entry file(ex. index.html) in the Default root object field.\n\n\nOnce the distribution is created and enabled, click into the distribution from console and you’ll get the distribution domain name. You can configure your DNS using this domain name in Route53 or Godaddy.\nI’m using Godaddy so it would be like this:\nRedirect domainIf you want to redirect myexample.com to www.myexample.com which is just configured with CloudFront distribution domain, in Godaddy, you can create a Forwarding rule:\n\nInvalidate CloudFront cacheUnder Invalidation tab, click Create Invalidation and add object path into it:\nSummarizeThis basic deployment with AWS stack includes AWS S3, CloudFront and ACM to enable SSL encryption. What is worth noticing is the S3 bucket policy definition and the region of ACM certificate should be requested in N. Virginia to make it work with CloudFront.\nWhat’s Next?After we deploy the website online, we need to make it visible in search engines which is out of this post’s scope. I’ll be having another post relevant to that in the feature.\nReferencehttps://docs.aws.amazon.com/acm/latest/userguide/acm-regions.html\nhttps://dale-bingham-soteriasoftware.medium.com/creating-a-static-website-using-godaddy-github-aws-s3-codedeploy-and-aws-cloudfront-1990a8f4ddd8\nhttps://tecadmin.net/remove-cloudfront-cache/\n","categories":["DevOps"],"tags":["AWS","S3","CloudFront","ACM"]},{"title":"Draw a triangle caret with pure CSS","url":"/2022/05/02/Draw-a-triangle-caret-with-pure-css/","content":"Prefix\nIt is very common that we need a triangle caret on a web page to display as an arrow or other similar symbols. It can be achieved by using a png or svg file, or importing from third-party icon library such as Font Awesome\n\nHowever, a more efficient low-carbon way is to draw it using CSS border attribute.\nA normal border\nThe most common use case of a border would be this:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    height: 100px;\n    width: 100px;\n    border: 5px solid #000;\n  &#125;\n&lt;/style&gt;\n\n\nIf we take a look at the border shape by giving a wider width of it, we will see it looks like this:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 200px;\n    height: 200px;\n    border-color: red blue yellow green;\n    border-style: solid;\n    border-width: 50px 50px 50px 50px;\n  &#125;\n&lt;/style&gt;\n\n\nBorder with zero height and width\nInstead of giving height and width to the box, when we set the width and height of the outer box to 0, the width of the border will stretch out the outer box, four sides of the borders will collapse together and each side of the border will be a triangle of 100px wide and 50px height, just like this:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 0;\n    height: 0;\n    border-color: red blue yellow green;\n    border-style: solid;\n    border-width: 50px 50px 50px 50px;\n  &#125;\n&lt;/style&gt;\n\n\nDisplay as a triangle\nNow what we need to do is to hide three other sides of the border and only show one of it:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 0;\n    height: 0;\n    border-color: red transparent transparent transparent;\n    border-style: solid;\n    border-width: 50px 50px 50px 50px;\n  &#125;\n&lt;/style&gt;\n\n\n#Other casesIf we try to set one side of the border width to be zero, we’ll get and rectangle with three triangles:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 0;\n    height: 0;\n    border-color: red blue yellow green;\n    border-style: solid;\n    border-width: 50px 50px 0 50px;\n  &#125;\n&lt;/style&gt;\n\n\nUse casesThis can be useful if we need a ribbon icon on page just like this:\n\nThe solution is to draw a rectangle on top and add a sudo class :after below it to implement 3 sides of the border:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 50px;\n    height: 70px;\n    background: red;\n    position: relative;\n  &#125;\n\n  .box:after &#123;\n    position: absolute;\n    left: 0;\n    top: 70px;\n    content: &#39;&#39;;\n    border-width: 12px 25px;\n    border-style: solid;\n    border-color: green green transparent green;\n  &#125;\n&lt;/style&gt;\n\n\nAnd we just need to set the color all red, and maybe add some text to make it a perfect ribbon.\n\n","categories":["Front-end"],"tags":["Web","CSS"]},{"title":"Implement a countdown timer in React Hooks","url":"/2022/04/02/Implement-a-countdown-timer-in-React-Hooks/","content":"Prefix\nFrom time to time we will see timers in the world of frontend, of which the use cases could be a count-down function, or a disabled button which will be released active after a certain amount of time to force users to read through site T&amp;C, or a button to send mobile code which is restricted to be clickable within a time interval after last click. Many front-end frameworks have already provided an out-of-box component of that such as ProFormCaptcha which to support common CAPTCHA functionality in the middle and backend.\nHowever, we will run into some cases that we need to customize the function as we wish and the provided function from the framework may have limitations. In this case we will need to implement this function by ourself.\nRequirements Analysis\nIdeally, we need to implement a button that behaves like this:\n\nFirst sms will be sent at the time the modal pops up, and the button start to count down util it reaches the time interval.\nAfter each count down, the button will be clickable and will start counting down after each click.\n\n\nImplementation in a React componentBasic setup:\nFrom the perspective of code, will need two states to manage this timer:\n\nA state to record the status of the button(disabled or active).\nA state to record time left after each seconds\n\nSo the basic code structure looks like this:\nimport React, &#123; useEffect, useState &#125; from &#39;react&#39;;\nimport &#123; Input, Button &#125; from &#39;@/my/components&#39;;\n\nconst TIME_INTERVAL = 59;\n\nexport default const TimerModal = () =&gt; &#123;\n    const [seconds, setSeconds] = useState&lt;number&gt;(TIME_INTERVAL);\n    const [isCounting, setIsCounting] = useState&lt;boolean&gt;(false);\n\n    const clickHandler = () =&gt; &#123;\n        sendCode();\n        // reset timer\n    &#125;\n    \n    return (\n        &lt;Input /&gt;\n        &lt;Button onClick=&#123;clickHandler&#125; disabled=&#123;isCounting&#125; /&gt;\n    );\n&#125;\n\nAdd timer logicFrom the requirement above we would know that the TimerModal will pop up and a first SMS has already been sent and the Timer button is disabled and start to count down. In this situation useEffect hook will be a perfect function to host the timer logic.\nuseEffect() dependency listTo listen to the change of the timer button and ensure timer works as we expected, we need to put two of the states(seconds and isCounting) to the dependency list of useEffect. \nInside of the timer logicWe achieve the expected result by updating the seconds(minus 1 in each call) inside a setInterval function. The initial seconds right after the Timer component is mounted is 59s, in the meanwhile, setInterval function inside useEffect hook will update seconds by deducting 1, and this will also trigger useEffect hook again and clear previous setInterval function and start a new session of setInterval() to minus seconds by 1 util it counts down to 1 second, which means the setInterval function is cleared and the countdown session status is reset to inactive(to set isCounting to false and seconds set to initial time interval) and the button will be clickable.\nAfter the button is clicked, the timer will be reset and a new cycle of the useEffect hook will start again.\nimport React, &#123; useEffect, useState &#125; from &#39;react&#39;;\nimport &#123; Input, Button &#125; from &#39;@/my/components&#39;;\n\nconst TIME_INTERVAL = 59;\n\nexport default const TimerModal = () =&gt; &#123;\n    const [seconds, setSeconds] = useState&lt;number&gt;(TIME_INTERVAL);\n    const [isCounting, setIsCounting] = useState&lt;boolean&gt;(true);\n\n    const resetTimer = () =&gt; &#123;\n        setSeconds(TIME_INTERVAL);\n        setIsCounting(true);\n    &#125;\n\n    useEffect((): () =&gt; void =&gt; &#123;\n        //setInterval Type would be number if uses window.setInterval()\n        let interval: null | NodeJS.Timer = null;\n        if (isCounting) &#123;\n            interval = setInterval(() =&gt; &#123;\n                setSeconds(seconds =&gt; &#123;\n                    if (seconds &gt; 1) &#123;\n                        return seconds - 1;\n                    &#125; else &#123;\n                        interval &amp;&amp; clearInterval(interval);\n                        setIsCounting(false);\n                        return TIME_INTERVAL;\n                    &#125;\n                &#125; );\n            &#125;, 1000);\n        &#125; else &#123;\n            interval &amp;&amp; clearInterval(interval);\n        &#125;\n    &#125;, [ isCounting, seconds ])\n\n    const clickHandler = () =&gt; &#123;\n        sendCode();\n        resetTimer();\n    &#125;\n\n    return (\n        &lt;Input /&gt;\n        &lt;Button onClick=&#123;clickHandler&#125; disabled=&#123;isCounting&#125; /&gt;\n    );\n&#125;\n\nReviewThe implementation above seems to perfectly fit the use case, one problem still hides under the hood and will cause memory leakage. If you are on the halfway during countdown session and the Timer component is unmounted(since it’s a modal and will be unmounted after it’s closed), the setInterval function is still there in the background. Luckily, the useEffect hook provides a return callback function to allow us unsubscribe any side effects outside of the React lifecycle, which will be called before the component is unmounted.In this case, we need to return a housekeeping function at the end of the useEffect callback function to clear the setInterval function. So the final code looks like this:\nimport React, &#123; useEffect, useState &#125; from &#39;react&#39;;\nimport &#123; Input, Button &#125; from &#39;@/my/components&#39;;\n\nconst TIME_INTERVAL = 59;\n\nexport default const TimerModal = () =&gt; &#123;\n    const [seconds, setSeconds] = useState&lt;number&gt;(TIME_INTERVAL);\n    const [isCounting, setIsCounting] = useState&lt;boolean&gt;(false);\n\n    const resetTimer = () =&gt; &#123;\n        setSeconds(TIME_INTERVAL);\n        setIsCounting(true);\n    &#125;\n\n    useEffect((): () =&gt; void =&gt; &#123;\n        //setInterval Type would be number if uses window.setInterval()\n        let interval: null | NodeJS.Timer = null;\n        if (isCounting) &#123;\n            interval = setInterval(() =&gt; &#123;\n                setSeconds(seconds =&gt; &#123;\n                    if (seconds &gt; 1) &#123;\n                        return seconds - 1;\n                    &#125; else &#123;\n                        interval &amp;&amp; clearInterval(interval);\n                        setIsCounting(false);\n                        return TIME_INTERVAL;\n                    &#125;\n                &#125; );\n            &#125;, 1000);\n        &#125; else &#123;\n            interval &amp;&amp; clearInterval(interval);\n        &#125;\n        // unsubscription\n        return () =&gt; interval &amp;&amp; clearInterval(interval);\n    &#125;, [ isCounting, seconds ])\n\n    const clickHandler = () =&gt; &#123;\n        sendCode();\n        resetTimer();\n    &#125;\n\n    return (\n        &lt;Input /&gt;\n        &lt;Button onClick=&#123;clickHandler&#125; disabled=&#123;isCounting&#125; /&gt;\n    );\n&#125;\n\nAnother takeaway from this case is that when we update the state which depends on the previous state, we can use a callback function inside useState() hook.the setState() function provided by useState hook accepts either a new state value or a callback function as an updater which returns a new state to set state based on the previous state.\nconst App = () =&gt; &#123;\n  const [num, setNum] = useState(0); // same API as useState\n\n  const handleClick = () =&gt; &#123;\n    setNum(prevState =&gt; prevState + 1);\n  &#125;;\n  return &lt;button onClick=&#123;handleClick&#125;&gt;Increment&lt;/button&gt;;\n&#125;\n\nSummaryThis is a use case that I encountered during development and I think this would be a perfect example to learn and demonstrate the concept of useEffect and useState hooks in React.js. When functional component started to take over class-based component, I firstly use the useEffect hook the way that I use componentDidMount(), componentDidUpdate() and componentDidUnmount() function. After a while, I started to learn that they may share most of the use cases, but the conception is different and useEffect hooks tends to be a much cleaner way to implement and manage a single logic at one place instead of having to use multiple lifecycle functions to trigger&#x2F;subscribe&#x2F;unsubscribe side effects.\nReferencesReact docs: https://reactjs.org/docs/hooks-effect.html\n","categories":["Front-end"],"tags":["Hooks","React","Web"]},{"title":"About Me","url":"/2022/03/12/hello-world/","content":"Welcome to my dev journal! This is your very first post. I’ll be sharing more posts regarding web development on this site in the near future.\nTo know more about me please see here\n"}]