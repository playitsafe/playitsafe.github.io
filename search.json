[{"title":"Deploy A Static Website via AWS S3, CloudFront and More","url":"/2022/06/04/Deploy-A-Website-via-AWS-S3-CloudFront-and-More/","content":"There are many different ways to deploy a website online. A dedicated server with Nginx or Apache, Github Pages and cloud service such as AWS or GCP can all do the trick. However, for a static website, a dedicated server might be a bit overkill as cloud service provides us a cheap, easy and sustainable way to deploy a static website. In this post, I will deploy a commercial website on AWS S3 bucket.\nPrerequisite\nA domain name purchased from domain provider such as Godaddy or AWS Route53.\nA built static website.\n\nArchitectureThe overview of the project architecture will be like this:\n\nCreate an S3 bucketCreate an S3 bucket on AWS and de-select Block Public Access settings to make it accessible by the public.\nAnd then, upload website resources to S3 bucket. Make sure an entry html is included.\nAlso, we’ll need to create a bucket policy to allow PublicReadGetObject permission. Under the permission tab of the bucket, edit bucket policy to add this rule:\n&#123;\n    &quot;Version&quot;: &quot;2012-10-17&quot;,\n    &quot;Statement&quot;: [\n        &#123;\n            &quot;Sid&quot;: &quot;PublicReadGetObject&quot;,\n            &quot;Effect&quot;: &quot;Allow&quot;,\n            &quot;Principal&quot;: &quot;*&quot;,\n            &quot;Action&quot;: &quot;s3:GetObject&quot;,\n            &quot;Resource&quot;: &quot;arn:aws:s3:::myexample.com/*&quot;\n        &#125;\n    ]\n&#125;\n\nRequest an SSL certificate from Amazon Certificate Manager(ACM):To use an ACM certificate with Amazon CloudFront, you must request or import the certificate in the US East (N. Virginia) region.\n\nYou will have CNAME key-value pairs generated for you to verify your domain. If you are using Route53 as a domain provider, simply click Create records in Route53. If you are using other providers such as godaddy, you will need to create these CNAME records so it can be verified.\nCreate a CloudFront distribution\nSelect the bucket for the Origin Domain. If your entry file is in a subfolder, you’ll need to put it in the Origin Path field.\n\nUnder the view settings, you you’d only allow https requests, you can select the Redirect HTTP to HTTPS option.\n\nAdd your domain name as alias in the Alternate domain name field.\n\nSelect the SSL certificate we just requested in the Custom SSL certificate field.\n\nPut your default entry file(ex. index.html) in the Default root object field.\n\n\nOnce the distribution is created and enabled, click into the distribution from console and you’ll get the distribution domain name. You can configure your DNS using this domain name in Route53 or Godaddy.\nI’m using Godaddy so it would be like this:\nRedirect domainIf you want to redirect myexample.com to www.myexample.com which is just configured with CloudFront distribution domain, in Godaddy, you can create a Forwarding rule:\n\nInvalidate CloudFront cacheUnder Invalidation tab, click Create Invalidation and add object path into it:\nCORS issuesIf you want to have encountered CORS issue when requesting static resources, you will need to configure the cloudFront distribution to forward the appropriate headers to the origin server - in this case the origin server is the S3 bucket.\nSo you’ll need to go to Behaviors tab in CloudFront console, choose edit or create(if no behavior is added). Under Cache key and origin requests, choose Cache policy and origin request policy.\n\nFor Cache policy, select CachingOptimized which is recommended for s3 origins;\nFor Origin request policy, select CORS-S3Origin\nFor Response headers policy, select SimpleCORS\n\nSee https://aws.amazon.com/premiumsupport/knowledge-center/no-access-control-allow-origin-error/ for more information.\n\nSummarizeThis basic deployment with AWS stack includes AWS S3, CloudFront and ACM to enable SSL encryption. What is worth noticing is the S3 bucket policy definition and the region of ACM certificate should be requested in N. Virginia to make it work with CloudFront.\nWhat’s Next?After we deploy the website online, we need to make it visible in search engines which is out of this post’s scope. I’ll be having another post relevant to that in the feature.\nReferencehttps://docs.aws.amazon.com/acm/latest/userguide/acm-regions.html\nhttps://dale-bingham-soteriasoftware.medium.com/creating-a-static-website-using-godaddy-github-aws-s3-codedeploy-and-aws-cloudfront-1990a8f4ddd8\nhttps://tecadmin.net/remove-cloudfront-cache/\n","categories":["DevOps"],"tags":["AWS","S3","CloudFront","ACM"]},{"title":"Draw a triangle caret with pure CSS","url":"/2022/05/03/Draw-a-triangle-caret-with-pure-css/","content":"Prefix\nIt is very common that we need a triangle caret on a web page to display as an arrow or other similar symbols. It can be achieved by using a png or svg file, or importing from third-party icon library such as Font Awesome\n\nHowever, a more efficient low-carbon way is to draw it using CSS border attribute.\nA normal border\nThe most common use case of a border would be this:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    height: 100px;\n    width: 100px;\n    border: 5px solid #000;\n  &#125;\n&lt;/style&gt;\n\n\nIf we take a look at the border shape by giving a wider width of it, we will see it looks like this:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 200px;\n    height: 200px;\n    border-color: red blue yellow green;\n    border-style: solid;\n    border-width: 50px 50px 50px 50px;\n  &#125;\n&lt;/style&gt;\n\n\nBorder with zero height and width\nInstead of giving height and width to the box, when we set the width and height of the outer box to 0, the width of the border will stretch out the outer box, four sides of the borders will collapse together and each side of the border will be a triangle of 100px wide and 50px height, just like this:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 0;\n    height: 0;\n    border-color: red blue yellow green;\n    border-style: solid;\n    border-width: 50px 50px 50px 50px;\n  &#125;\n&lt;/style&gt;\n\n\nDisplay as a triangle\nNow what we need to do is to hide three other sides of the border and only show one of it:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 0;\n    height: 0;\n    border-color: red transparent transparent transparent;\n    border-style: solid;\n    border-width: 50px 50px 50px 50px;\n  &#125;\n&lt;/style&gt;\n\n\n#Other casesIf we try to set one side of the border width to be zero, we’ll get and rectangle with three triangles:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 0;\n    height: 0;\n    border-color: red blue yellow green;\n    border-style: solid;\n    border-width: 50px 50px 0 50px;\n  &#125;\n&lt;/style&gt;\n\n\nUse casesThis can be useful if we need a ribbon icon on page just like this:\n\nThe solution is to draw a rectangle on top and add a sudo class :after below it to implement 3 sides of the border:\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;style&gt;\n  .box &#123;\n    width: 50px;\n    height: 70px;\n    background: red;\n    position: relative;\n  &#125;\n\n  .box:after &#123;\n    position: absolute;\n    left: 0;\n    top: 70px;\n    content: &#39;&#39;;\n    border-width: 12px 25px;\n    border-style: solid;\n    border-color: green green transparent green;\n  &#125;\n&lt;/style&gt;\n\n\nAnd we just need to set the color all red, and maybe add some text to make it a perfect ribbon.\n\n","categories":["Front-end"],"tags":["CSS","Web"]},{"title":"A Peek at useRequest hook","url":"/2022/07/31/A-Peek-at-useRequest-hook/","content":"Introduction\nuseRequest is a powerful, well-encapsulated hook from a hook library ahooks to manage async data fetching. When there is multiple async logic in a single component in React, we will deal with a bunch of useState and useEffect hooks, which makes it complicated to call APIs.\nWhat it probably looks like:\n// Component.ts\nconst [ data, setData ] = useState&lt;object&gt;(defaultData)\nconst [ isLoading, setIsloading ] = useState&lt;boolean&gt;(false)\n\nuseEffect(() =&gt; &#123;\n    setIsloading(true)\n  request = service.fetchData(...)\n  setData(...)\n  handlerError(...)\n    setIsloading(false)\n&#125;, [])\n\nWith the help of useRequest, we can simplify our code:\nimport &#123; useRequest &#125; from &quot;ahooks&quot;;\n\nconst &#123;\n  data,\n  run: request,\n  loading,\n  error,\n&#125; = useRequest(service.serviceA, options);\n\nMain features\nuseRequest provides sufficient enough functionalities for network request scenarios in React projects including:\n\nAutomatic&#x2F;manual request\nPolling\nDebounce\nThrottling\nRefresh on window focus\nError retry\nLoading delay\nSWR(stale-while-revalidate)\nCaching\n\nA Glance on Basic Usage\nLoading delaySet the delay time for loading to become true\nconst &#123; loading, data &#125; = useRequest(getUsername, &#123;\n  loadingDelay: 300, //Set the delay time for loading to become true\n&#125;);\n\nreturn &lt;div&gt;&#123;loading ? &quot;Loading...&quot; : data&#125;&lt;/div&gt;;\n\nPollingBy setting options.pollingInterval , enter the polling mode, useRequest  will periodically trigger service execution.\nconst &#123; data, run, cancel &#125; = useRequest(getUsername, &#123;\n  pollingInterval: 3000, //will periodically trigger service execution.\n&#125;);\n\nRefresh on window focusthe request will be refreshed when the browser is refocus  and revisible.\nconst &#123; data &#125; = useRequest(getUsername, &#123;\n  refreshOnWindowFocus: true,\n&#125;);\n\nDebounce &amp; ThrottlingEnter the debounce mode by setting options.debounceWait &#x2F; options.throttleWait. At this time, if run or runAsync is triggered frequently, the request will be executed with the debounce&#x2F;throttle strategy.\nconst &#123; data, run &#125; = useRequest(getUsername, &#123;\n  debounceWait: 300,\n  throttleWait: 300,\n  manual: true,\n&#125;);\n\nCache &amp; SWRIf options.cacheKey  is set, useRequest  will cache the successful data . The next time the component is initialized, if there is cached data, it will return the cached data first, and then send a new request in background, which is the ability of SWR.\nasync function getArticle(): Promise&lt;&#123; data: string; time: number &#125;&gt; &#123;\n  console.log(&quot;cacheKey&quot;);\n  return new Promise((resolve) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n      resolve(&#123;\n        data: Mock.mock(&quot;@paragraph&quot;),\n        time: new Date().getTime(),\n      &#125;);\n    &#125;, 1000);\n  &#125;);\n&#125;\n\nconst Article = () =&gt; &#123;\n  const &#123; data, loading &#125; = useRequest(getArticle, &#123;\n    cacheKey: &quot;cacheKey-demo&quot;,\n  &#125;);\n  if (!data &amp;&amp; loading) &#123;\n    return &lt;p&gt;Loading&lt;/p&gt;;\n  &#125;\n  return (\n    &lt;&gt;\n      &lt;p&gt;Background loading: &#123;loading ? &quot;true&quot; : &quot;false&quot;&#125;&lt;/p&gt;\n      &lt;p&gt;Latest request time: &#123;data?.time&#125;&lt;/p&gt;\n      &lt;p&gt;&#123;data?.data&#125;&lt;/p&gt;\n    &lt;/&gt;\n  );\n&#125;;\n\nError retryBy setting options.retryCount , set the number of error retries, useRequest will retry after it fails.\nconst &#123; data, run &#125; = useRequest(getUsername, &#123;\n  retryCount: 3,\n&#125;);\n\nDesign PatternuseRequest has two main modules that work together to serve its functionality: the main Fetch class and plugins\nThe Plugin module uses varieties of different plugins, each of which only works for a specific function.\nFetch module on the other hand is even more simple - to implement the Fetch class which aggregates all plugins to this hook to make it robust and easy to maintain.\n\nSource code\nFetch - the coreStructure of Fetch class:\nexport default class Fetch&lt;TData, TParams extends any[]&gt; &#123;\n  pluginImpls: PluginReturn&lt;TData, TParams&gt;[];\n\n  count: number = 0;\n\n  state: FetchState&lt;TData, TParams&gt; = &#123;\n    loading: false,\n    params: undefined,\n    data: undefined,\n    error: undefined,\n  &#125;;\n\n  constructor(\n    public serviceRef: MutableRefObject&lt;Service&lt;TData, TParams&gt;&gt;,\n    public options: Options&lt;TData, TParams&gt;,\n    public subscribe: Subscribe,\n    public initState: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;,\n  ) &#123;\n    this.state = &#123;\n      ...this.state,\n      loading: !options.manual,\n      ...initState,\n    &#125;;\n  &#125;\n\n  setState(s: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;) &#123;...&#125;\n\n  runPluginHandler(event: keyof PluginReturn&lt;TData, TParams&gt;, ...rest: any[]) &#123;...&#125;\n\n  async runAsync(...params: TParams): Promise&lt;TData&gt; &#123;...&#125;\n\n  run(...params: TParams) &#123;...&#125;\n\n  cancel() &#123;...&#125;\n\n  refresh() &#123;...&#125;\n\n  refreshAsync() &#123;...&#125;\n\n  mutate(data?: TData | ((oldData?: TData) =&gt; TData | undefined)) &#123;...&#125;\n\nMost of its API is provided for the user to call such as run、runAsync、cancel、refresh、refreshAsync、mutate, while runPluginHandler、setState are for internal use.\npluginImplsAs per its properties, we can see it has a pluginImpls property, from its type PluginReturn&lt;TData, TParams&gt;[] it seems to contain results of all plugins after execution.\nexport interface PluginReturn&lt;TData, TParams extends any[]&gt; &#123;\n  onBefore?: (params: TParams) =&gt;\n    | (&#123;\n        stopNow?: boolean;\n        returnNow?: boolean;\n      &#125; &amp; Partial&lt;FetchState&lt;TData, TParams&gt;&gt;)\n    | void;\n\n  onRequest?: (\n    service: Service&lt;TData, TParams&gt;,\n    params: TParams\n  ) =&gt; &#123;\n    servicePromise?: Promise&lt;TData&gt;;\n  &#125;;\n\n  onSuccess?: (data: TData, params: TParams) =&gt; void;\n  onError?: (e: Error, params: TParams) =&gt; void;\n  onFinally?: (params: TParams, data?: TData, e?: Error) =&gt; void;\n  onCancel?: () =&gt; void;\n  onMutate?: (data: TData) =&gt; void;\n&#125;\n\nInside the PluginReturn&lt;TData, TParams&gt; type, it stores some lifecycle callback hooks which will be called at a certain phase of the request.\nstateThere’s also a state property of FetchState&lt;TData, TParams&gt; type. The type definition below shows it stores the context of the request. loading ,data, errors are the results we’d like to get from useRequest\nexport interface FetchState&lt;TData, TParams extends any[]&gt; &#123;\n  loading: boolean;\n  params?: TParams;\n  data?: TData;\n  error?: Error;\n&#125;\n\nconst &#123; data, error, loading &#125; = useRequest(service);\n\nAnd the setState API is used to update the state.\nTwo main APIs of the Fetch class are runPluginHandler and runAsync , which are called by all of the other APIs to do some extra work.\nrunPluginHandlerrunPluginHandler(event: keyof PluginReturn&lt;TData, TParams&gt;, ...rest: any[]) &#123;\n    // @ts-ignore\n  const r = this.pluginImpls.map((i) =&gt; i[event]?.(...rest)).filter(Boolean);\n  return Object.assign(&#123;&#125;, ...r);\n&#125;\n\nThis function accepts an event parameter which is of the union type onBefore | onRequest | onSuccess | onError | onFinally | onCancel | onMutate and other extra parameters. What this handler does is to call the relevant lifecycle hook from pluginImpls and return its result.\nrunAsyncasync runAsync(...params: TParams): Promise&lt;TData&gt; &#123;\n    this.count += 1;\n    const currentCount = this.count;\n\n    const &#123;\n      stopNow = false,\n      returnNow = false,\n      ...state\n    &#125; = this.runPluginHandler(&#39;onBefore&#39;, params);\n\n    // stop request\n    if (stopNow) &#123;\n      return new Promise(() =&gt; &#123;&#125;);\n    &#125;\n\n    this.setState(&#123;\n      loading: true,\n      params,\n      ...state,\n    &#125;);\n\n    // return now\n    if (returnNow) &#123;\n      return Promise.resolve(state.data);\n    &#125;\n\n    this.options.onBefore?.(params);\n\n    try &#123;\n      // replace service\n      let &#123; servicePromise &#125; = this.runPluginHandler(&#39;onRequest&#39;, this.serviceRef.current, params);\n\n      if (!servicePromise) &#123;\n        servicePromise = this.serviceRef.current(...params);\n      &#125;\n\n      const res = await servicePromise;\n\n      if (currentCount !== this.count) &#123;\n        // prevent run.then when request is canceled\n        return new Promise(() =&gt; &#123;&#125;);\n      &#125;\n\n      // const formattedResult = this.options.formatResultRef.current ? this.options.formatResultRef.current(res) : res;\n\n      this.setState(&#123;\n        data: res,\n        error: undefined,\n        loading: false,\n      &#125;);\n\n      this.options.onSuccess?.(res, params);\n      this.runPluginHandler(&#39;onSuccess&#39;, res, params);\n\n      this.options.onFinally?.(params, res, undefined);\n\n      if (currentCount === this.count) &#123;\n        this.runPluginHandler(&#39;onFinally&#39;, params, res, undefined);\n      &#125;\n\n      return res;\n    &#125; catch (error) &#123;\n      if (currentCount !== this.count) &#123;\n        // prevent run.then when request is canceled\n        return new Promise(() =&gt; &#123;&#125;);\n      &#125;\n\n      this.setState(&#123;\n        error,\n        loading: false,\n      &#125;);\n\n      this.options.onError?.(error, params);\n      this.runPluginHandler(&#39;onError&#39;, error, params);\n\n      this.options.onFinally?.(params, undefined, error);\n\n      if (currentCount === this.count) &#123;\n        this.runPluginHandler(&#39;onFinally&#39;, params, undefined, error);\n      &#125;\n\n      throw error;\n    &#125;\n  &#125;\n\nWhat this long function does is to implement callbacks that are passed in to give users the opportunity to process the result of the request instead of handling it automatically.\nFor example, In an onBefore hook, user can cancel a request before it’s been sent out ; In an onRequest hook, the function to fetch data can be overwritten, etc.\nOther APIsOther APIs such as run、cancel、refresh will eventually call runPluginHandler and runAsync .\nThe main responsibility of this Fetch class is to run callbacks in different phases of a request lifecycle and update the state.\nPluginsThe implementation of useRequest separates the core logic and the complicity of each different functionality by the plugin mechanism. Fetch only care about when to call those plugin hooks and each plugin itself will only focus on customizing and doing its own logic.\nTake usePollingPlugin as an example, the main logic of this plugin is to set a timeout in onFinally callback after each request using pollingInterval passed by users and run refresh function of the Fetch instance.\nconst usePollingPlugin: Plugin&lt;any, any[]&gt; = (\n  fetchInstance,\n  &#123; pollingInterval, pollingWhenHidden = true &#125;\n) =&gt; &#123;\n  const timerRef = useRef&lt;NodeJS.Timeout&gt;();\n  const unsubscribeRef = useRef&lt;() =&gt; void&gt;();\n\n  const stopPolling = () =&gt; &#123;\n    if (timerRef.current) &#123;\n      clearTimeout(timerRef.current);\n    &#125;\n    unsubscribeRef.current?.();\n  &#125;;\n\n  useUpdateEffect(() =&gt; &#123;\n    if (!pollingInterval) &#123;\n      stopPolling();\n    &#125;\n  &#125;, [pollingInterval]);\n\n  if (!pollingInterval) &#123;\n    return &#123;&#125;;\n  &#125;\n\n  return &#123;\n    onBefore: () =&gt; &#123;\n      stopPolling();\n    &#125;,\n    onFinally: () =&gt; &#123;\n      // if pollingWhenHidden = false &amp;&amp; document is hidden, then stop polling and subscribe revisible\n      if (!pollingWhenHidden &amp;&amp; !isDocumentVisible()) &#123;\n        unsubscribeRef.current = subscribeReVisible(() =&gt; &#123;\n          fetchInstance.refresh();\n        &#125;);\n        return;\n      &#125;\n\n      timerRef.current = setTimeout(() =&gt; &#123;\n        fetchInstance.refresh();\n      &#125;, pollingInterval);\n    &#125;,\n    onCancel: () =&gt; &#123;\n      stopPolling();\n    &#125;,\n  &#125;;\n&#125;;\n\nAdding upTo hook up the core Fetch class and plugins together to make this hook work, useRequestImplement is called and accepts request options and plugins from a higher level and Fetch will be instantiated inside the function.\nfunction useRequestImplement&lt;TData, TParams extends any[]&gt;(\n  service: Service&lt;TData, TParams&gt;,\n  options: Options&lt;TData, TParams&gt; = &#123;&#125;,\n  plugins: Plugin&lt;TData, TParams&gt;[] = []\n) &#123;\n  const &#123; manual = false, ...rest &#125; = options;\n\n  const fetchOptions = &#123;\n    manual,\n    ...rest,\n  &#125;;\n\n  const serviceRef = useLatest(service);\n\n  const update = useUpdate();\n\n  const fetchInstance = useCreation(() =&gt; &#123;\n    const initState = plugins\n      .map((p) =&gt; p?.onInit?.(fetchOptions))\n      .filter(Boolean);\n\n    return new Fetch&lt;TData, TParams&gt;(\n      serviceRef,\n      fetchOptions,\n      update,\n      Object.assign(&#123;&#125;, ...initState)\n    );\n  &#125;, []);\n  fetchInstance.options = fetchOptions;\n  // run all plugins hooks\n  fetchInstance.pluginImpls = plugins.map((p) =&gt;\n    p(fetchInstance, fetchOptions)\n  );\n\n  useMount(() =&gt; &#123;\n    if (!manual) &#123;\n      // useCachePlugin can set fetchInstance.state.params from cache when init\n      const params = fetchInstance.state.params || options.defaultParams || [];\n      // @ts-ignore\n      fetchInstance.run(...params);\n    &#125;\n  &#125;);\n\n  useUnmount(() =&gt; &#123;\n    fetchInstance.cancel();\n  &#125;);\n\n  return &#123;\n    loading: fetchInstance.state.loading,\n    data: fetchInstance.state.data,\n    error: fetchInstance.state.error,\n    params: fetchInstance.state.params || [],\n    cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)),\n    refresh: useMemoizedFn(fetchInstance.refresh.bind(fetchInstance)),\n    refreshAsync: useMemoizedFn(fetchInstance.refreshAsync.bind(fetchInstance)),\n    run: useMemoizedFn(fetchInstance.run.bind(fetchInstance)),\n    runAsync: useMemoizedFn(fetchInstance.runAsync.bind(fetchInstance)),\n    mutate: useMemoizedFn(fetchInstance.mutate.bind(fetchInstance)),\n  &#125; as Result&lt;TData, TParams&gt;;\n&#125;\n\nexport default useRequestImplement;\n\nFinally, this function will be returned in a useRequest function with custom plugins along with its native plugins passed in.\nfunction useRequest&lt;TData, TParams extends any[]&gt;(\n  service: Service&lt;TData, TParams&gt;,\n  options?: Options&lt;TData, TParams&gt;,\n  plugins?: Plugin&lt;TData, TParams&gt;[]\n) &#123;\n  return useRequestImplement&lt;TData, TParams&gt;(service, options, [\n    ...(plugins || []),\n    useDebouncePlugin,\n    useLoadingDelayPlugin,\n    usePollingPlugin,\n    useRefreshOnWindowFocusPlugin,\n    useThrottlePlugin,\n    useRefreshDeps,\n    useCachePlugin,\n    useRetryPlugin,\n    useReadyPlugin,\n  ] as Plugin&lt;TData, TParams&gt;[]);\n&#125;\n\nSummariseThe main idea of implementing a plugin is to find out the appropriate phase of the request lifecycle and plug in the core logic of the hook. The most important takeaway from the exploration of the hook’s source code is the approach of separating its core Fetch function and its plugins, which makes it more reusable and maintainable. Users are able to extend the plugins easily as they wish and each of the plugins works independently. I believe it’s a great example of the single responsibility principle and that’s something I could borrow from when customizing a hook or implementing complicated logic.\nReferencehttps://ahooks.js.org/hooks/use-request/basichttps://github.com/alibaba/hooks/tree/master/packages/hooks/src/useRequest/srchttps://qdmana.com/2022/02/202202020201538966.html\n","categories":["Front-end"],"tags":["Web","Hooks","React"]},{"title":"Implement a countdown timer in React Hooks","url":"/2022/04/02/Implement-a-countdown-timer-in-React-Hooks/","content":"Prefix\nFrom time to time we will see timers in the world of frontend, of which the use cases could be a count-down function, or a disabled button which will be released active after a certain amount of time to force users to read through site T&amp;C, or a button to send mobile code which is restricted to be clickable within a time interval after last click. Many front-end frameworks have already provided an out-of-box component of that such as ProFormCaptcha which to support common CAPTCHA functionality in the middle and backend.\nHowever, we will run into some cases that we need to customize the function as we wish and the provided function from the framework may have limitations. In this case we will need to implement this function by ourself.\nRequirements Analysis\nIdeally, we need to implement a button that behaves like this:\n\nFirst sms will be sent at the time the modal pops up, and the button start to count down util it reaches the time interval.\nAfter each count down, the button will be clickable and will start counting down after each click.\n\n\nImplementation in a React componentBasic setup:\nFrom the perspective of code, will need two states to manage this timer:\n\nA state to record the status of the button(disabled or active).\nA state to record time left after each seconds\n\nSo the basic code structure looks like this:\nimport React, &#123; useEffect, useState &#125; from &#39;react&#39;;\nimport &#123; Input, Button &#125; from &#39;@/my/components&#39;;\n\nconst TIME_INTERVAL = 59;\n\nexport default const TimerModal = () =&gt; &#123;\n    const [seconds, setSeconds] = useState&lt;number&gt;(TIME_INTERVAL);\n    const [isCounting, setIsCounting] = useState&lt;boolean&gt;(false);\n\n    const clickHandler = () =&gt; &#123;\n        sendCode();\n        // reset timer\n    &#125;\n    \n    return (\n        &lt;Input /&gt;\n        &lt;Button onClick=&#123;clickHandler&#125; disabled=&#123;isCounting&#125; /&gt;\n    );\n&#125;\n\nAdd timer logicFrom the requirement above we would know that the TimerModal will pop up and a first SMS has already been sent and the Timer button is disabled and start to count down. In this situation useEffect hook will be a perfect function to host the timer logic.\nuseEffect() dependency listTo listen to the change of the timer button and ensure timer works as we expected, we need to put two of the states(seconds and isCounting) to the dependency list of useEffect. \nInside of the timer logicWe achieve the expected result by updating the seconds(minus 1 in each call) inside a setInterval function. The initial seconds right after the Timer component is mounted is 59s, in the meanwhile, setInterval function inside useEffect hook will update seconds by deducting 1, and this will also trigger useEffect hook again and clear previous setInterval function and start a new session of setInterval() to minus seconds by 1 util it counts down to 1 second, which means the setInterval function is cleared and the countdown session status is reset to inactive(to set isCounting to false and seconds set to initial time interval) and the button will be clickable.\nAfter the button is clicked, the timer will be reset and a new cycle of the useEffect hook will start again.\nimport React, &#123; useEffect, useState &#125; from &#39;react&#39;;\nimport &#123; Input, Button &#125; from &#39;@/my/components&#39;;\n\nconst TIME_INTERVAL = 59;\n\nexport default const TimerModal = () =&gt; &#123;\n    const [seconds, setSeconds] = useState&lt;number&gt;(TIME_INTERVAL);\n    const [isCounting, setIsCounting] = useState&lt;boolean&gt;(true);\n\n    const resetTimer = () =&gt; &#123;\n        setSeconds(TIME_INTERVAL);\n        setIsCounting(true);\n    &#125;\n\n    useEffect((): () =&gt; void =&gt; &#123;\n        //setInterval Type would be number if uses window.setInterval()\n        let interval: null | NodeJS.Timer = null;\n        if (isCounting) &#123;\n            interval = setInterval(() =&gt; &#123;\n                setSeconds(seconds =&gt; &#123;\n                    if (seconds &gt; 1) &#123;\n                        return seconds - 1;\n                    &#125; else &#123;\n                        interval &amp;&amp; clearInterval(interval);\n                        setIsCounting(false);\n                        return TIME_INTERVAL;\n                    &#125;\n                &#125; );\n            &#125;, 1000);\n        &#125; else &#123;\n            interval &amp;&amp; clearInterval(interval);\n        &#125;\n    &#125;, [ isCounting, seconds ])\n\n    const clickHandler = () =&gt; &#123;\n        sendCode();\n        resetTimer();\n    &#125;\n\n    return (\n        &lt;Input /&gt;\n        &lt;Button onClick=&#123;clickHandler&#125; disabled=&#123;isCounting&#125; /&gt;\n    );\n&#125;\n\nReviewThe implementation above seems to perfectly fit the use case, one problem still hides under the hood and will cause memory leakage. If you are on the halfway during countdown session and the Timer component is unmounted(since it’s a modal and will be unmounted after it’s closed), the setInterval function is still there in the background. Luckily, the useEffect hook provides a return callback function to allow us unsubscribe any side effects outside of the React lifecycle, which will be called before the component is unmounted.In this case, we need to return a housekeeping function at the end of the useEffect callback function to clear the setInterval function. So the final code looks like this:\nimport React, &#123; useEffect, useState &#125; from &#39;react&#39;;\nimport &#123; Input, Button &#125; from &#39;@/my/components&#39;;\n\nconst TIME_INTERVAL = 59;\n\nexport default const TimerModal = () =&gt; &#123;\n    const [seconds, setSeconds] = useState&lt;number&gt;(TIME_INTERVAL);\n    const [isCounting, setIsCounting] = useState&lt;boolean&gt;(false);\n\n    const resetTimer = () =&gt; &#123;\n        setSeconds(TIME_INTERVAL);\n        setIsCounting(true);\n    &#125;\n\n    useEffect((): () =&gt; void =&gt; &#123;\n        //setInterval Type would be number if uses window.setInterval()\n        let interval: null | NodeJS.Timer = null;\n        if (isCounting) &#123;\n            interval = setInterval(() =&gt; &#123;\n                setSeconds(seconds =&gt; &#123;\n                    if (seconds &gt; 1) &#123;\n                        return seconds - 1;\n                    &#125; else &#123;\n                        interval &amp;&amp; clearInterval(interval);\n                        setIsCounting(false);\n                        return TIME_INTERVAL;\n                    &#125;\n                &#125; );\n            &#125;, 1000);\n        &#125; else &#123;\n            interval &amp;&amp; clearInterval(interval);\n        &#125;\n        // unsubscription\n        return () =&gt; interval &amp;&amp; clearInterval(interval);\n    &#125;, [ isCounting, seconds ])\n\n    const clickHandler = () =&gt; &#123;\n        sendCode();\n        resetTimer();\n    &#125;\n\n    return (\n        &lt;Input /&gt;\n        &lt;Button onClick=&#123;clickHandler&#125; disabled=&#123;isCounting&#125; /&gt;\n    );\n&#125;\n\nAnother takeaway from this case is that when we update the state which depends on the previous state, we can use a callback function inside useState() hook.the setState() function provided by useState hook accepts either a new state value or a callback function as an updater which returns a new state to set state based on the previous state.\nconst App = () =&gt; &#123;\n  const [num, setNum] = useState(0); // same API as useState\n\n  const handleClick = () =&gt; &#123;\n    setNum(prevState =&gt; prevState + 1);\n  &#125;;\n  return &lt;button onClick=&#123;handleClick&#125;&gt;Increment&lt;/button&gt;;\n&#125;\n\nSummaryThis is a use case that I encountered during development and I think this would be a perfect example to learn and demonstrate the concept of useEffect and useState hooks in React.js. When functional component started to take over class-based component, I firstly use the useEffect hook the way that I use componentDidMount(), componentDidUpdate() and componentDidUnmount() function. After a while, I started to learn that they may share most of the use cases, but the conception is different and useEffect hooks tends to be a much cleaner way to implement and manage a single logic at one place instead of having to use multiple lifecycle functions to trigger&#x2F;subscribe&#x2F;unsubscribe side effects.\nReferencesReact docs: https://reactjs.org/docs/hooks-effect.html\n","categories":["Front-end"],"tags":["Web","Hooks","React"]},{"title":"Typescript challenge series(2)","url":"/2022/08/10/Typescript-challenge-series-2/","content":"\nPrefixI found a repo on Github about Typescript not long ago which provides a bunch of exercises which helps us to understand the fundamental of Typescript. As most of projects nowadays are using Typescript to implement static typing, I decided to follow along and see how I’ll go with those challenges.\nHow to play around with it?There are questions of different levels in the questions directory, each of which has a README, test-cases and template. The challenge is to modify the type in template to make test cases all pass in test-cases .\nLet’s get started!\n00014 Easy First of ArrayImplement a generic First&lt;T&gt; that takes an Array T and returns it’s first element’s type.For example:\ntype arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\ntype arr2 = [3, 2, 1];\n\ntype head1 = First&lt;arr1&gt;; // expected to be &#39;a&#39;\ntype head2 = First&lt;arr2&gt;; // expected to be 3\n\nTestsimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\ntype cases = [\n  Expect&lt;Equal&lt;First&lt;[3, 2, 1]&gt;, 3&gt;&gt;,\n  Expect&lt;Equal&lt;First&lt;[() =&gt; 123, &#123; a: string &#125;]&gt;, () =&gt; 123&gt;&gt;,\n  Expect&lt;Equal&lt;First&lt;[]&gt;, never&gt;&gt;,\n  Expect&lt;Equal&lt;First&lt;[undefined]&gt;, undefined&gt;&gt;\n];\n\ntype errors = [\n  // @ts-expect-error\n  First&lt;&quot;notArray&quot;&gt;,\n  // @ts-expect-error\n  First&lt;&#123; 0: &quot;arrayLike&quot; &#125;&gt;\n];\n\nSolution 1Our first thought was like this:\ntype First&lt;T extends any[]&gt; = T[0];\n\nThis will solve most of test cases, but failed when T is an empty array. So we can add a conditional return:\ntype First&lt;T extends any[]&gt; = T extends [] ? never : T[0];\n\nSolution 2Instead of checking T extends [], we can check its length type. From previous tests we know there’s a length property on array&#x2F;tuple type, so we can do:\ntype First&lt;T extends any[]&gt; = T[&quot;length&quot;] extends 0 ? never : T[0];\n\nSolution 3We can also check if T[0] is in array:\ntype First&lt;T extends any[]&gt; = T[0] extends T[number] ? T[0] : never;\n\nSolution 4We can also use infer to get the type of the first element of the array:\ntype First&lt;T extends any[]&gt; = T extends [infer FIRST, ...infer REST]\n  ? FIRST\n  : never;\n\n00018 Easy Tuple LengthCreate a generic Length, pick the length of the tuple.\nFor example:\ntype tesla = [&quot;tesla&quot;, &quot;model 3&quot;, &quot;model X&quot;, &quot;model Y&quot;];\ntype spaceX = [\n  &quot;FALCON 9&quot;,\n  &quot;FALCON HEAVY&quot;,\n  &quot;DRAGON&quot;,\n  &quot;STARSHIP&quot;,\n  &quot;HUMAN SPACEFLIGHT&quot;\n];\n\ntype teslaLength = Length&lt;tesla&gt;; // expected 4\ntype spaceXLength = Length&lt;spaceX&gt;; // expected 5\n\nTestsimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\nconst tesla = [&quot;tesla&quot;, &quot;model 3&quot;, &quot;model X&quot;, &quot;model Y&quot;] as const;\nconst spaceX = [\n  &quot;FALCON 9&quot;,\n  &quot;FALCON HEAVY&quot;,\n  &quot;DRAGON&quot;,\n  &quot;STARSHIP&quot;,\n  &quot;HUMAN SPACEFLIGHT&quot;,\n] as const;\n\ntype cases = [\n  Expect&lt;Equal&lt;Length&lt;typeof tesla&gt;, 4&gt;&gt;,\n  Expect&lt;Equal&lt;Length&lt;typeof spaceX&gt;, 5&gt;&gt;,\n  // @ts-expect-error\n  Length&lt;5&gt;,\n  // @ts-expect-error\n  Length&lt;&quot;hello world&quot;&gt;\n];\n\nSolutionThis is an easy one. From the examples and tests we can see Length accepts constant tuple. and we can use length property of array&#x2F;tuple type to get the length. So it’ll be like this:\ntype Length&lt;T extends readonly any[]&gt; = T[&quot;length&quot;];\n\nSummary👉 keyof T OperatorTo get all keys as a union type from a type or interface, we can use mapped types in.\ntype Point = &#123; x: number; y: number &#125;;\ntype P = keyof Point;\n\n// P is the same type as “x” | “y”\n\nMore on this: https://www.typescriptlang.org/docs/handbook/2/keyof-types.html#handbook-content\n👉 [KEY in KTYPES]A mapped type is a generic type which uses a union of PropertyKeys (frequently created via a keyof) to iterate through keys to create a type.\nMore on this:https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#handbook-content\n👉 TODO[KEY]Indexed access type. We can use an indexed access type to look up a specific property on another type:\ntype Person = &#123; age: number; name: string; alive: boolean &#125;;\ntype Age = Person[&quot;age&quot;];\n\n// type Age = number\n\nIndexed access type can also get the length of an array as a type.\nconst arr = [1, 3, 4];\ntype TLength = arr[&quot;length&quot;];\n\nMore on this: https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html#handbook-content\n👉 extendsThe keyword extends stands for constraints when defining a generic type.\n👉 Native ReadOnly type will do as the following:\n interface Todo &#123;\n   title: string\n   description: string\n &#125;\n\n const todo: Readonly&lt;Todo&gt; = &#123;\n   title: &quot;Hey&quot;,\n   description: &quot;foobar&quot;\n &#125;\n\n // will make `todo` as a readonly object:\n  const todo: &lt;Todo&gt; = &#123;\n   readonly title: &quot;Hey&quot;,\n   readonly description: &quot;foobar&quot;\n &#125;\n\nMore on ReadOnly: https://www.tutorialsteacher.com/typescript/typescript-readonly\n👉 as const operatorconst tuple = [&#39;tesla&#39;, &#39;model 3&#39;] as const\n\n// will be equivalent to\n\ntypeof tuple = readonly [&#39;tesla&#39;, &#39;model 3&#39;]`\n\n👉 To get all values from an array type:We can do ARR[number] to get all values as an union type of the array type ARR and use E in ARR[number] to iterate through.\n👉 To get type of the first element in an arrayT[0]\n👉 Get length of an arrayT[&#39;length&#39;] &#x2F;&#x2F;also known as indexed\n👉 extends union typeIf we check whether a extends a|2|3, it will check every type in union type to see if they match.\n👉 infer in array destructionT extends [infer FIRST, ...infer REST] ? FIRST : never\n\nif FIRST can be successfully destructed, then return FIRST\nconst arr: any[] = []\nconst [a, ...b] = arr\n\na ==&gt; undefined\nb ==&gt; []\n\nTo be continued…\n","categories":["Front-end"],"tags":["Typescript","Javascript"]},{"title":"Typescript challenge series(1)","url":"/2022/08/06/Typescript-challenge-series-1/","content":"\nPrefixI found a repo on Github about Typescript not long ago which provides a bunch of exercises which helps us to understand the fundamental of Typescript. As most of projects nowadays are using Typescript to implement static typing, I decided to follow along and see how I’ll go with those challenges.\nHow to play around with it?There are questions of different levels in the questions directory, each of which has a README, test-cases and template. The challenge is to modify the type in template to make test cases all pass in test-cases .\nLet’s get started from the easy ones!\n00004 Easy PickImplement the built-in Pick&lt;T, K&gt; generic without using it.\nConstructs a type by picking the set of properties K from T\nFor example:\ninterface Todo &#123;\n  title: string;\n  description: string;\n  completed: boolean;\n&#125;\n\ntype TodoPreview = MyPick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;\n\nconst todo: TodoPreview = &#123;\n  title: &quot;Clean room&quot;,\n  completed: false,\n&#125;;\n\nTestsimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\ntype cases = [\n  Expect&lt;Equal&lt;Expected1, MyPick&lt;Todo, &quot;title&quot;&gt;&gt;&gt;,\n  Expect&lt;Equal&lt;Expected2, MyPick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;&gt;&gt;,\n  // @ts-expect-error\n  MyPick&lt;Todo, &quot;title&quot; | &quot;completed&quot; | &quot;invalid&quot;&gt;\n];\n\ninterface Todo &#123;\n  title: string;\n  description: string;\n  completed: boolean;\n&#125;\n\ninterface Expected1 &#123;\n  title: string;\n&#125;\n\ninterface Expected2 &#123;\n  title: string;\n  completed: boolean;\n&#125;\n\nSolutiontype MyPick should work as the same as the native Pick type in Typescript, which will generated a new type the the picked property keys from the given type&#x2F;interface with same value type of the picked key. See Pick in Typescript docs here: https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys\nFirst of all, we need to ensure the second generic type will extend T‘s properties:\ntype MyPick&lt;T, KEYS extends keyof T&gt; = &#123;&#125;;\n\nThen, we can use mapped types to specify all key types of KEYS, and use indexed access type to specify the value type:\ntype MyPick&lt;T, KEYS extends keyof T&gt; = &#123;\n  [K in KEYS]: T[K];\n&#125;;\n\nAt this stage, all test cases should pass with no complaining errors.\n00007 Easy ReadonlyImplement the built-in Readonly&lt;T&gt; generic without using it.\nConstructs a type with all properties of T set to readonly, meaning the properties of the constructed type cannot be reassigned.\nFor example:\ninterface Todo &#123;\n  title: string;\n  description: string;\n&#125;\n\nconst todo: MyReadonly&lt;Todo&gt; = &#123;\n  title: &quot;Hey&quot;,\n  description: &quot;foobar&quot;,\n&#125;;\n\ntodo.title = &quot;Hello&quot;; // Error: cannot reassign a readonly property\ntodo.description = &quot;barFoo&quot;; // Error: cannot reassign a readonly property\n\nTestsimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\ntype cases = [Expect&lt;Equal&lt;MyReadonly&lt;Todo1&gt;, Readonly&lt;Todo1&gt;&gt;&gt;];\n\ninterface Todo1 &#123;\n  title: string;\n  description: string;\n  completed: boolean;\n  meta: &#123;\n    author: string;\n  &#125;;\n&#125;\n\nSolutionThis is a simple one. The solution is to use mapped type to iterate through Todo and add readonly to each of its keys.\ntype MyReadonly&lt;T&gt; = &#123;\n  readonly [KEY in keyof T]: T[KEY];\n&#125;;\n\nThis shall make its tests all pass.\n00011 Easy TupleGive an array, transform into an object type and the key&#x2F;value must in the given array.\nFor example:\nconst tuple = [&quot;tesla&quot;, &quot;model 3&quot;, &quot;model X&quot;, &quot;model Y&quot;] as const;\n\ntype result = TupleToObject&lt;typeof tuple&gt;; // expected &#123; tesla: &#39;tesla&#39;, &#39;model 3&#39;: &#39;model 3&#39;, &#39;model X&#39;: &#39;model X&#39;, &#39;model Y&#39;: &#39;model Y&#39;&#125;\n\nTestsimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\nconst tuple = [&quot;tesla&quot;, &quot;model 3&quot;, &quot;model X&quot;, &quot;model Y&quot;] as const;\nconst tupleNumber = [1, 2, 3, 4] as const;\nconst tupleMix = [1, &quot;2&quot;, 3, &quot;4&quot;] as const;\n\ntype cases = [\n  Expect&lt;\n    Equal&lt;\n      TupleToObject&lt;typeof tuple&gt;,\n      &#123;\n        tesla: &quot;tesla&quot;;\n        &quot;model 3&quot;: &quot;model 3&quot;;\n        &quot;model X&quot;: &quot;model X&quot;;\n        &quot;model Y&quot;: &quot;model Y&quot;;\n      &#125;\n    &gt;\n  &gt;,\n  Expect&lt;Equal&lt;TupleToObject&lt;typeof tupleNumber&gt;, &#123; 1: 1; 2: 2; 3: 3; 4: 4 &#125;&gt;&gt;,\n  Expect&lt;\n    Equal&lt;TupleToObject&lt;typeof tupleMix&gt;, &#123; 1: 1; &quot;2&quot;: &quot;2&quot;; 3: 3; &quot;4&quot;: &quot;4&quot; &#125;&gt;\n  &gt;\n];\n\n// @ts-expect-errorr\ntype error = TupleToObject&lt;[[1, 2], &#123;&#125;]&gt;;\n\nSolutionFirst we need to ensure that this type accepts const arrays(tuples):\ntype TupleToObject&lt;T extends readonly any[]&gt; = any;\n\nNext, we want to get all of the value inside of it as a union type to iterate through the tuple just like we use mapped type to iterate through an object type.In array&#x2F;tuple, we cannot use keypf T operator, instead we can treat array as an object-like type that has number as key of each of its element - we can do T[number] to get all of its values. So it’s going to be like this:\ntype TupleToObject&lt;T extends readonly any[]&gt; = &#123;\n  [VAL in T[number]]: VAL;\n&#125;;\n\nTill now we solve most of the test cases, except for the error handling case:\ntype error = TupleToObject&lt;[[1, 2], &#123;&#125;]&gt;;\n\nWe can see it doesn’t like empty object or array&#x2F;tuple element to be inside. So the simplest way is to use extends to constrain the type to be number or string\ntype TupleToObject&lt;T extends readonly (number | string)[]&gt; = &#123;\n  [VAL in T[number]]: VAL;\n&#125;;\n\nNow it’s all good!\n00014 Easy First of ArrayImplement a generic First&lt;T&gt; that takes an Array T and returns it’s first element’s type.For example:\ntype arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\ntype arr2 = [3, 2, 1];\n\ntype head1 = First&lt;arr1&gt;; // expected to be &#39;a&#39;\ntype head2 = First&lt;arr2&gt;; // expected to be 3\n\nTestsimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\ntype cases = [\n  Expect&lt;Equal&lt;First&lt;[3, 2, 1]&gt;, 3&gt;&gt;,\n  Expect&lt;Equal&lt;First&lt;[() =&gt; 123, &#123; a: string &#125;]&gt;, () =&gt; 123&gt;&gt;,\n  Expect&lt;Equal&lt;First&lt;[]&gt;, never&gt;&gt;,\n  Expect&lt;Equal&lt;First&lt;[undefined]&gt;, undefined&gt;&gt;\n];\n\ntype errors = [\n  // @ts-expect-error\n  First&lt;&quot;notArray&quot;&gt;,\n  // @ts-expect-error\n  First&lt;&#123; 0: &quot;arrayLike&quot; &#125;&gt;\n];\n\nSolution 1Our first thought was like this:\ntype First&lt;T extends any[]&gt; = T[0];\n\nThis will solve most of test cases, but failed when T is an empty array. So we can add a conditional return:\ntype First&lt;T extends any[]&gt; = T extends [] ? never : T[0];\n\nSolution 2Instead of checking T extends [], we can check its length type. From previous tests we know there’s a length property on array&#x2F;tuple type, so we can do:\ntype First&lt;T extends any[]&gt; = T[&quot;length&quot;] extends 0 ? never : T[0];\n\nSolution 3We can also check if T[0] is in array:\ntype First&lt;T extends any[]&gt; = T[0] extends T[number] ? T[0] : never;\n\nSolution 4We can also use infer to get the type of the first element of the array:\ntype First&lt;T extends any[]&gt; = T extends [infer FIRST, ...infer REST]\n  ? FIRST\n  : never;\n\n00018 Easy Tuple LengthCreate a generic Length, pick the length of the tuple.\nFor example:\ntype tesla = [&quot;tesla&quot;, &quot;model 3&quot;, &quot;model X&quot;, &quot;model Y&quot;];\ntype spaceX = [\n  &quot;FALCON 9&quot;,\n  &quot;FALCON HEAVY&quot;,\n  &quot;DRAGON&quot;,\n  &quot;STARSHIP&quot;,\n  &quot;HUMAN SPACEFLIGHT&quot;\n];\n\ntype teslaLength = Length&lt;tesla&gt;; // expected 4\ntype spaceXLength = Length&lt;spaceX&gt;; // expected 5\n\nTestsimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\nconst tesla = [&quot;tesla&quot;, &quot;model 3&quot;, &quot;model X&quot;, &quot;model Y&quot;] as const;\nconst spaceX = [\n  &quot;FALCON 9&quot;,\n  &quot;FALCON HEAVY&quot;,\n  &quot;DRAGON&quot;,\n  &quot;STARSHIP&quot;,\n  &quot;HUMAN SPACEFLIGHT&quot;,\n] as const;\n\ntype cases = [\n  Expect&lt;Equal&lt;Length&lt;typeof tesla&gt;, 4&gt;&gt;,\n  Expect&lt;Equal&lt;Length&lt;typeof spaceX&gt;, 5&gt;&gt;,\n  // @ts-expect-error\n  Length&lt;5&gt;,\n  // @ts-expect-error\n  Length&lt;&quot;hello world&quot;&gt;\n];\n\nSolutionThis is an easy one. From the examples and tests we can see Length accepts constant tuple. and we can use length property of array&#x2F;tuple type to get the length. So it’ll be like this:\ntype Length&lt;T extends readonly any[]&gt; = T[&quot;length&quot;];\n\nSummary👉 keyof T OperatorTo get all keys as a union type from a type or interface, we can use mapped types in.\ntype Point = &#123; x: number; y: number &#125;;\ntype P = keyof Point;\n\n// P is the same type as “x” | “y”\n\nMore on this: https://www.typescriptlang.org/docs/handbook/2/keyof-types.html#handbook-content\n👉 [KEY in KTYPES]A mapped type is a generic type which uses a union of PropertyKeys (frequently created via a keyof) to iterate through keys to create a type.\nMore on this:https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#handbook-content\n👉 TODO[KEY]Indexed access type. We can use an indexed access type to look up a specific property on another type:\ntype Person = &#123; age: number; name: string; alive: boolean &#125;;\ntype Age = Person[&quot;age&quot;];\n\n// type Age = number\n\nIndexed access type can also get the length of an array as a type.\nconst arr = [1, 3, 4];\ntype TLength = arr[&quot;length&quot;];\n\nMore on this: https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html#handbook-content\n👉 extendsThe keyword extends stands for constraints when defining a generic type.\n👉 Native ReadOnly type will do as the following:\n interface Todo &#123;\n   title: string\n   description: string\n &#125;\n\n const todo: Readonly&lt;Todo&gt; = &#123;\n   title: &quot;Hey&quot;,\n   description: &quot;foobar&quot;\n &#125;\n\n // will make `todo` as a readonly object:\n  const todo: &lt;Todo&gt; = &#123;\n   readonly title: &quot;Hey&quot;,\n   readonly description: &quot;foobar&quot;\n &#125;\n\nMore on ReadOnly: https://www.tutorialsteacher.com/typescript/typescript-readonly\n👉 as const operatorconst tuple = [&#39;tesla&#39;, &#39;model 3&#39;] as const\n\n// will be equivalent to\n\ntypeof tuple = readonly [&#39;tesla&#39;, &#39;model 3&#39;]`\n\n👉 To get all values from an array type:We can do ARR[number] to get all values as an union type of the array type ARR and use E in ARR[number] to iterate through.\n👉 To get type of the first element in an arrayT[0]\n👉 Get length of an arrayT[&#39;length&#39;] &#x2F;&#x2F;also known as indexed\n👉 extends union typeIf we check whether a extends a|2|3, it will check every type in union type to see if they match.\n👉 infer in array destructionT extends [infer FIRST, ...infer REST] ? FIRST : never\n\nif FIRST can be successfully destructed, then return FIRST\nconst arr: any[] = []\nconst [a, ...b] = arr\n\na ==&gt; undefined\nb ==&gt; []\n\nTo be continued…\n","categories":["Front-end"],"tags":["Typescript","Javascript"]},{"title":"Typescript challenge series(4)","url":"/2023/01/05/Typescript-challenge-series-4/","content":"\nPrefixI found a repo on Github about Typescript not long ago which provides a bunch of exercises which helps us to understand the fundamental of Typescript. As most of projects nowadays are using Typescript to implement static typing, I decided to follow along and see how I’ll go with those challenges.\nHow to play around with it?There are questions of different levels in the questions directory, each of which has a README, test-cases and template. The challenge is to modify the type in template to make test cases all pass in test-cases .\nLet’s get started!\n00268 Easy IfImplement a util If which accepts condition C, a truthy return type T, and a falsy return type F. C is expected to be either true or false while T and F can be any type.\nFor example:\ntype A = If&lt;true, &quot;a&quot;, &quot;b&quot;&gt;; // expected to be &#39;a&#39;\ntype B = If&lt;false, &quot;a&quot;, &quot;b&quot;&gt;; // expected to be &#39;b&#39;\n\nTestsimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\ntype cases = [\n  Expect&lt;Equal&lt;If&lt;true, &quot;a&quot;, &quot;b&quot;&gt;, &quot;a&quot;&gt;&gt;,\n  Expect&lt;Equal&lt;If&lt;false, &quot;a&quot;, 2&gt;, 2&gt;&gt;\n];\n\n// @ts-expect-error\ntype error = If&lt;null, &quot;a&quot;, &quot;b&quot;&gt;;\n\nSolutionThis is an easy one. From previous questions we know we can restrict C to extend boolean and use a tertiary expression to return T or F.\ntype If&lt;C extends boolean, T, F&gt; = C extends true ? T : F;\n\nBy now we should get all tests pass. If there’s still any error in type error = If&lt;null, &#39;a&#39;, &#39;b&#39;&gt;, it is because in TS non-strict mode, null can extend boolean. We can simple turn on strict mode.\n    &quot;strict&quot;: true, // Enable all strict type-checking options.\n    &quot;strictNullChecks&quot;: true, // When type checking, take into account &#39;null&#39; and &#39;undefined&#39;.\n\n00898 Easy includesImplement the JavaScript Array.includes function in the type system. A type takes the two arguments. The output should be a boolean true or false.\nFor example:\ntype isPillarMen = Includes&lt;[&quot;Kars&quot;, &quot;Esidisi&quot;, &quot;Wamuu&quot;, &quot;Santana&quot;], &quot;Dio&quot;&gt;; // expected to be `false`\n\nTest casesimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\nimport &#123; Includes &#125; from &quot;./template&quot;;\n\ntype cases = [\n  Expect&lt;\n    Equal&lt;Includes&lt;[&quot;Kars&quot;, &quot;Esidisi&quot;, &quot;Wamuu&quot;, &quot;Santana&quot;], &quot;Kars&quot;&gt;, true&gt;\n  &gt;,\n  Expect&lt;\n    Equal&lt;Includes&lt;[&quot;Kars&quot;, &quot;Esidisi&quot;, &quot;Wamuu&quot;, &quot;Santana&quot;], &quot;Dio&quot;&gt;, false&gt;\n  &gt;,\n  Expect&lt;Equal&lt;Includes&lt;[1, 2, 3, 5, 6, 7], 7&gt;, true&gt;&gt;,\n  Expect&lt;Equal&lt;Includes&lt;[1, 2, 3, 5, 6, 7], 4&gt;, false&gt;&gt;,\n  Expect&lt;Equal&lt;Includes&lt;[1, 2, 3], 2&gt;, true&gt;&gt;,\n  Expect&lt;Equal&lt;Includes&lt;[1, 2, 3], 1&gt;, true&gt;&gt;,\n  Expect&lt;Equal&lt;Includes&lt;[&#123;&#125;], &#123; a: &quot;A&quot; &#125;&gt;, false&gt;&gt;,\n  Expect&lt;Equal&lt;Includes&lt;[boolean, 2, 3, 5, 6, 7], false&gt;, false&gt;&gt;,\n  Expect&lt;Equal&lt;Includes&lt;[true, 2, 3, 5, 6, 7], boolean&gt;, false&gt;&gt;,\n  Expect&lt;Equal&lt;Includes&lt;[false, 2, 3, 5, 6, 7], false&gt;, true&gt;&gt;,\n  Expect&lt;Equal&lt;Includes&lt;[&#123; a: &quot;A&quot; &#125;], &#123; readonly a: &quot;A&quot; &#125;&gt;, false&gt;&gt;,\n  Expect&lt;Equal&lt;Includes&lt;[&#123; readonly a: &quot;A&quot; &#125;], &#123; a: &quot;A&quot; &#125;&gt;, false&gt;&gt;,\n  Expect&lt;Equal&lt;Includes&lt;[1], 1 | 2&gt;, false&gt;&gt;,\n  Expect&lt;Equal&lt;Includes&lt;[1 | 2], 1&gt;, false&gt;&gt;,\n  Expect&lt;Equal&lt;Includes&lt;[null], undefined&gt;, false&gt;&gt;,\n  Expect&lt;Equal&lt;Includes&lt;[undefined], null&gt;, false&gt;&gt;\n];\n\nSolutionMy first thought on this one would be this:\ntype Includes&lt;T extends readonly any[], U&gt; = U extends T[number] ? true : false;\n\nUnfortunately, it fails on some tests. The reason is the expression U extends T[number] ? true : false will compare the type of every elements in T with U, and return true or false for each comparison, in the end, the type would be a union type of all true&#x2F;false results.true | true would be true and true | false will be boolean\nWe can use another approach to use infer to get each element of the array and use the provided Equal function to recursively do comparisons.\ntype Includes&lt;T extends readonly any[], U&gt;\n  = T extends [infer FIRST, ...infer REST]\n    ? Equal&lt;FIRST, U&gt; ? true : Includes&lt;REST, U&gt;\n    : false\n\nSummaryWe can recursively use this Include type by passing REST as a generic type.\n03057 Easy Push &amp; 03060 Easy UnshiftImplement the generic version of Array.push\nFor example:\ntype Result = Push&lt;[1, 2], &quot;3&quot;&gt;; // [1, 2, &#39;3&#39;]\n\nImplement the type version of Array.unshift\nFor example:\ntype Result = Unshift&lt;[1, 2], 0&gt;; // [0, 1, 2,]\n\nThe Solution would be the same as concat, which is to use the spread operator to create a new array type.\n// Push\ntype Push&lt;T extends any[], U&gt; = [...T, U];\n\n// Unshift\ntype Push&lt;T extends any[], U&gt; = [...T, U];\n\nSummaryThe spread operator can also be used on type.\n03312 Easy ParameterImplement the built-in Parameters&lt;T&gt; generic without using it.\nFor example:\nconst foo = (arg1: string, arg2: number): void =&gt; &#123;&#125;;\n\ntype FunctionParamsType = MyParameters&lt;typeof foo&gt;; // [arg1: string, arg2: number]\n\nTestingimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\nconst foo = (arg1: string, arg2: number): void =&gt; &#123;&#125;;\nconst bar = (arg1: boolean, arg2: &#123; a: &quot;A&quot; &#125;): void =&gt; &#123;&#125;;\nconst baz = (): void =&gt; &#123;&#125;;\n\ntype cases = [\n  Expect&lt;Equal&lt;MyParameters&lt;typeof foo&gt;, [string, number]&gt;&gt;,\n  Expect&lt;Equal&lt;MyParameters&lt;typeof bar&gt;, [boolean, &#123; a: &quot;A&quot; &#125;]&gt;&gt;,\n  Expect&lt;Equal&lt;MyParameters&lt;typeof baz&gt;, []&gt;&gt;\n];\n\nSolutionWe can use infer to get the type of function parameter.\ntype MyParameters&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...infer ARGS) =&gt; any ? ARGS : never\n\nTill now, we have finish all EASY level questions.🎉🎉\n","categories":["Front-end"],"tags":["Typescript","Javascript"]},{"title":"Typescript challenge series(5)","url":"/2023/02/16/Typescript-challenge-series-5/","content":"\nPrefixI found a repo on Github about Typescript not long ago which provides a bunch of exercises which helps us to understand the fundamental of Typescript. As most of projects nowadays are using Typescript to implement static typing, I decided to follow along and see how I’ll go with those challenges.\nHow to play around with it?There are questions of different levels in the questions directory, each of which has a README, test-cases and template. The challenge is to modify the type in template to make test cases all pass in test-cases .\nLet’s get started from the easy ones!\n00002 Medium Return TypeImplement the built-in ReturnType&lt;T&gt; generic without using it.\nFor example\nconst fn = (v: boolean) =&gt; &#123;\n  if (v) return 1;\n  else return 2;\n&#125;;\n\ntype a = MyReturnType&lt;typeof fn&gt;; // should be &quot;1 | 2&quot;\n\nTeststype cases = [\n  Expect&lt;Equal&lt;string, MyReturnType&lt;() =&gt; string&gt;&gt;&gt;,\n  Expect&lt;Equal&lt;123, MyReturnType&lt;() =&gt; 123&gt;&gt;&gt;,\n  Expect&lt;Equal&lt;ComplexObject, MyReturnType&lt;() =&gt; ComplexObject&gt;&gt;&gt;,\n  Expect&lt;Equal&lt;Promise&lt;boolean&gt;, MyReturnType&lt;() =&gt; Promise&lt;boolean&gt;&gt;&gt;&gt;,\n  Expect&lt;Equal&lt;() =&gt; &quot;foo&quot;, MyReturnType&lt;() =&gt; () =&gt; &quot;foo&quot;&gt;&gt;&gt;,\n  Expect&lt;Equal&lt;1 | 2, MyReturnType&lt;typeof fn&gt;&gt;&gt;,\n  Expect&lt;Equal&lt;1 | 2, MyReturnType&lt;typeof fn1&gt;&gt;&gt;\n];\n\ntype ComplexObject = &#123;\n  a: [12, &quot;foo&quot;];\n  bar: &quot;hello&quot;;\n  prev(): number;\n&#125;;\n\nconst fn = (v: boolean) =&gt; (v ? 1 : 2);\nconst fn1 = (v: boolean, w: any) =&gt; (v ? 1 : 2);\n\nSolutionsWe need to use infer to get the returning type of the function.\ntype MyReturnType&lt;T&gt; = T extends () =&gt; infer R ? R : never;\n\nThis will pass most of the tests, but not for those functions with parameters. So we need to specify parameters for the function type.\ntype MyReturnType&lt;T&gt; = T extends (...args: any) =&gt; infer R ? R : never;\n\nReferencehttps://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types\n00003 Medium OmitImplement the built-in Omit&lt;T, K&gt; generic without using it.\nConstructs a type by picking all properties from T and then removing K\nFor example\ninterface Todo &#123;\n  title: string;\n  description: string;\n  completed: boolean;\n&#125;\n\ntype TodoPreview = MyOmit&lt;Todo, &quot;description&quot; | &quot;title&quot;&gt;;\n\nconst todo: TodoPreview = &#123;\n  completed: false,\n&#125;;\n\nTestsimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\ntype cases = [\n  Expect&lt;Equal&lt;Expected1, MyOmit&lt;Todo, &quot;description&quot;&gt;&gt;&gt;,\n  Expect&lt;Equal&lt;Expected2, MyOmit&lt;Todo, &quot;description&quot; | &quot;completed&quot;&gt;&gt;&gt;\n];\n\n// @ts-expect-error\ntype error = MyOmit&lt;Todo, &quot;description&quot; | &quot;invalid&quot;&gt;;\n\ninterface Todo &#123;\n  title: string;\n  description: string;\n  completed: boolean;\n&#125;\n\ninterface Expected1 &#123;\n  title: string;\n  completed: boolean;\n&#125;\n\ninterface Expected2 &#123;\n  title: string;\n&#125;\n\nSolutionTo solve this one, we’ll need to use Exclude to remove the specified keys and get the rest key with their value in type.\ntype MyOmit&lt;T, K extends keyof T&gt; = &#123;\n  [KEY in Exclude&lt;keyof T, K&gt;]: T[KEY];\n&#125;;\n\nExclude&lt;keyof T, K&gt; returns the remaining keys, and we can just use mapped types KEY in TYPES to get all remaining keys.\nReferencehttps://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys\nhttps://www.typescriptlang.org/docs/handbook/utility-types.html#excludeuniontype-excludedmembers\n00008 Medium Readonly 2Implement a generic MyReadonly2&lt;T, K&gt; which takes two type argument T and K.\nK specify the set of properties of T that should set to Readonly. When K is not provided, it should make all properties readonly just like the normal Readonly&lt;T&gt;.\nFor example\ninterface Todo &#123;\n  title: string;\n  description: string;\n  completed: boolean;\n&#125;\n\nconst todo: MyReadonly2&lt;Todo, &quot;title&quot; | &quot;description&quot;&gt; = &#123;\n  title: &quot;Hey&quot;,\n  description: &quot;foobar&quot;,\n  completed: false,\n&#125;;\n\ntodo.title = &quot;Hello&quot;; // Error: cannot reassign a readonly property\ntodo.description = &quot;barFoo&quot;; // Error: cannot reassign a readonly property\ntodo.completed = true; // OK\n\nTestsimport type &#123; Alike, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\ntype cases = [\n  Expect&lt;Alike&lt;MyReadonly2&lt;Todo1&gt;, Readonly&lt;Todo1&gt;&gt;&gt;,\n  Expect&lt;Alike&lt;MyReadonly2&lt;Todo1, &quot;title&quot; | &quot;description&quot;&gt;, Expected&gt;&gt;,\n  Expect&lt;Alike&lt;MyReadonly2&lt;Todo2, &quot;title&quot; | &quot;description&quot;&gt;, Expected&gt;&gt;\n];\n\ninterface Todo1 &#123;\n  title: string;\n  description?: string;\n  completed: boolean;\n&#125;\n\ninterface Todo2 &#123;\n  readonly title: string;\n  description?: string;\n  completed: boolean;\n&#125;\n\ninterface Expected &#123;\n  readonly title: string;\n  readonly description?: string;\n  completed: boolean;\n&#125;\n\nSolutionFrom the example we know that we need to implement fields specified in K to be readonly. The idea is to separate those specified fields from the others and add readonly operator.\nWe can use omit to get those non-readonly properties via Omit\ntype MyReadonly2&lt;T, K extends keyof T&gt; = Omit&lt;T, K&gt; &amp; &#123;\n  readonly [KEY in K]: T[KEY];\n&#125;;\n\nThis would mostly make tests pass, except for the first one, which hasn’t specified any K. This case we would make all fields readonly. So it would be equivalent as we specified all of its properties. So we need to give it a default value.\ntype MyReadonly2&lt;T, K extends keyof T = keyof T&gt; = Omit&lt;T, K&gt; &amp; &#123;\n  readonly [KEY in K]: T[KEY];\n&#125;;\n\nSummary👉 Default generic typeGeneric type can have a default type just like Javascript.\n👉 Union types via &amp;:https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#unions\n👉 Omit:https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys\n","categories":["Front-end"],"tags":["Typescript","Javascript"]},{"title":"Typescript challenge series(6)","url":"/2023/08/26/Typescript-challenge-series-6/","content":"\nPrefixI found a repo on Github about Typescript not long ago which provides a bunch of exercises which helps us to understand the fundamental of Typescript. As most of projects nowadays are using Typescript to implement static typing, I decided to follow along and see how I’ll go with those challenges.\nHow to play around with it?There are questions of different levels in the questions directory, each of which has a README, test-cases and template. The challenge is to modify the type in template to make test cases all pass in test-cases .\nLet’s get started from the easy ones!\n00009 Medium Deep ReadonlyImplement a generic DeepReadonly&lt;T&gt; which make every parameter of an object - and its sub-objects recursively - readonly.\nYou can assume that we are only dealing with Objects in this challenge. Arrays, Functions, Classes and so on do not need to be taken into consideration. However, you can still challenge yourself by covering as many different cases as possible.\nFor example:\ntype X = &#123;\n  x: &#123;\n    a: 1;\n    b: &quot;hi&quot;;\n  &#125;;\n  y: &quot;hey&quot;;\n&#125;;\n\ntype Expected = &#123;\n  readonly x: &#123;\n    readonly a: 1;\n    readonly b: &quot;hi&quot;;\n  &#125;;\n  readonly y: &quot;hey&quot;;\n&#125;;\n\ntype Todo = DeepReadonly&lt;X&gt;; // should be same as `Expected`\n\nTestsimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\ntype cases = [Expect&lt;Equal&lt;DeepReadonly&lt;X&gt;, Expected&gt;&gt;];\n\ntype X = &#123;\n  a: () =&gt; 22;\n  b: string;\n  c: &#123;\n    d: boolean;\n    e: &#123;\n      g: &#123;\n        h: &#123;\n          i: true;\n          j: &quot;string&quot;;\n        &#125;;\n        k: &quot;hello&quot;;\n      &#125;;\n      l: [\n        &quot;hi&quot;,\n        &#123;\n          m: [&quot;hey&quot;];\n        &#125;\n      ];\n    &#125;;\n  &#125;;\n&#125;;\n\ntype Expected = &#123;\n  readonly a: () =&gt; 22;\n  readonly b: string;\n  readonly c: &#123;\n    readonly d: boolean;\n    readonly e: &#123;\n      readonly g: &#123;\n        readonly h: &#123;\n          readonly i: true;\n          readonly j: &quot;string&quot;;\n        &#125;;\n        readonly k: &quot;hello&quot;;\n      &#125;;\n      readonly l: readonly [\n        &quot;hi&quot;,\n        &#123;\n          readonly m: readonly [&quot;hey&quot;];\n        &#125;\n      ];\n    &#125;;\n  &#125;;\n&#125;;\n\nSolutionThis should be an easy one. The trick is to use mapped types and recursively apply this type.\ntype DeepReadonly&lt;T&gt; = &#123;\n  readonly [KEY in keyof T]: T extends object ? DeepReadonly&lt;T[KEY]&gt; : T[KEY];\n&#125;;\n\nThis won’t just make all the test pass as we need to deal with Function as it is a type of object\ntype DeepReadonly&lt;T&gt; = &#123;\n  readonly [KEY in keyof T]: T[KEY] extends Function\n    ? T[KEY]\n    : T[KEY] extends object\n    ? DeepReadonly&lt;T[KEY]&gt;\n    : T[KEY];\n&#125;;\n\nSummary👉 Function extends object\n00010 Medium Tuple to UnionImplement a generic TupleToUnion&lt;T&gt; which covers the values of a tuple to its values union.\nFor example\ntype Arr = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;];\n\ntype Test = TupleToUnion&lt;Arr&gt;; // expected to be &#39;1&#39; | &#39;2&#39; | &#39;3&#39;\n\nTestsimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\ntype cases = [\n  Expect&lt;Equal&lt;TupleToUnion&lt;[123, &quot;456&quot;, true]&gt;, 123 | &quot;456&quot; | true&gt;&gt;,\n  Expect&lt;Equal&lt;TupleToUnion&lt;[123]&gt;, 123&gt;&gt;\n];\n\nSolution 1The easiest solution is to use Indexed Access Type to iterate through the tuple type. From previous questions we know that we can iterate through an array&#x2F;tuple to get all its elements as an union type:\ntype TupleToUnion&lt;T extends any[]&gt; = T[number];\n\nSolution 2Another approach is to use infer to recursively get each element from the tuple to form an union type.\ntype TupleToUnion&lt;T&gt; = T extends [infer FIRST, ...infer REST]\n  ? FIRST | TupleToUnion&lt;REST&gt;\n  : never;\n\nSummary👉 Array&#x2F;Tuple type can be iterated by index access type as there is a number key on it.\n","categories":["Front-end"],"tags":["Typescript","Javascript"]},{"title":"Typescript challenge series(3)","url":"/2022/08/13/Typescript-challenge-series-3/","content":"\nPrefixI found a repo on Github about Typescript not long ago which provides a bunch of exercises which helps us to understand the fundamental of Typescript. As most of projects nowadays are using Typescript to implement static typing, I decided to follow along and see how I’ll go with those challenges.\nHow to play around with it?There are questions of different levels in the questions directory, each of which has a README, test-cases and template. The challenge is to modify the type in template to make test cases all pass in test-cases .\nLet’s get started!\n00043 Easy ExcludeImplement the built-in Exclude&lt;T, U&gt;\ntype Result = MyExclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;;\n// &#39;b&#39; | &#39;c&#39;\n\nTestsimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\ntype cases = [\n  Expect&lt;Equal&lt;MyExclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;, &quot;b&quot; | &quot;c&quot;&gt;&gt;,\n  Expect&lt;Equal&lt;MyExclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;, &quot;c&quot;&gt;&gt;,\n  Expect&lt;\n    Equal&lt;MyExclude&lt;string | number | (() =&gt; void), Function&gt;, string | number&gt;\n  &gt;\n];\n\nSolutionWhen both sides of extends are union types, extends will iterate through each type inside to check.\ntype MyExclude&lt;T, U&gt; = T extends U ? never : T;\n\nSummary👉 T extends UUnion type will iterate through each union type to check if every type in T exists in a type in U. It works like a for loop in javascript. And it will return the result as a union type as well.\n00533 Easy ConcatImplement the JavaScript Array.concat function in the type system. A type takes the two arguments. The output should be a new array that includes inputs in ltr order.\nFor example:\ntype Result = Concat&lt;[1], [2]&gt;; // expected to be [1, 2]\n\nTeststype cases = [\n  Expect&lt;Equal&lt;Concat&lt;[], []&gt;, []&gt;&gt;,\n  Expect&lt;Equal&lt;Concat&lt;[], [1]&gt;, [1]&gt;&gt;,\n  Expect&lt;Equal&lt;Concat&lt;[1, 2], [3, 4]&gt;, [1, 2, 3, 4]&gt;&gt;,\n  Expect&lt;\n    Equal&lt;\n      Concat&lt;[&quot;1&quot;, 2, &quot;3&quot;], [false, boolean, &quot;4&quot;]&gt;,\n      [&quot;1&quot;, 2, &quot;3&quot;, false, boolean, &quot;4&quot;]\n    &gt;\n  &gt;\n];\n\nSolutionThis one can be easily done by using spread operator:\ntype Concat&lt;T extends any[], U extends any[]&gt; = [...T, ...U];\n\nSummary👉 Spread operator ...Spread operator can also be used in Typescript.\n00189 Easy AwaitedWe need to get a type which is inside the wrapped type.\ntype ExampleType = Promise&lt;string&gt;;\n\ntype Result = MyAwaited&lt;ExampleType&gt;; // string\n\nTestsimport type &#123; Equal, Expect &#125; from &quot;@type-challenges/utils&quot;;\n\ntype X = Promise&lt;string&gt;;\ntype Y = Promise&lt;&#123; field: number &#125;&gt;;\ntype Z = Promise&lt;Promise&lt;string | number&gt;&gt;;\ntype Z1 = Promise&lt;Promise&lt;Promise&lt;string | boolean&gt;&gt;&gt;;\n\ntype cases = [\n  Expect&lt;Equal&lt;MyAwaited&lt;X&gt;, string&gt;&gt;,\n  Expect&lt;Equal&lt;MyAwaited&lt;Y&gt;, &#123; field: number &#125;&gt;&gt;,\n  Expect&lt;Equal&lt;MyAwaited&lt;Z&gt;, string | number&gt;&gt;,\n  Expect&lt;Equal&lt;MyAwaited&lt;Z1&gt;, string | boolean&gt;&gt;\n];\n\n// @ts-expect-error\ntype error = MyAwaited&lt;number&gt;;\n\nSolutionFirst of all, we can see MyAwaited only accepts Promise type as its generic type, so we can do this first:\ntype MyAwaited&lt;T extends Promise&lt;any&gt;&gt; = any;\n\nThen, we can use infer to get the type inside the Promise\ntype MyAwaited&lt;T extends Promise&lt;any&gt;&gt; = T extends Promise&lt;infer INSIDE&gt;\n  ? INSIDE\n  : never;\n\nAt this stage, we have solved first two of the test cases. Remaining test cases required us to get the type inside the nested Promise type. So we need to check the INSIDE type is a Promise type as well. If so, we can recursively use MyAwaited type.\ntype MyAwaited&lt;T extends Promise&lt;any&gt;&gt; = T extends Promise&lt;infer INSIDE&gt;\n  ? INSIDE extends Promise&lt;any&gt;\n    ? MyAwaited&lt;INSIDE&gt;\n    : INSIDE\n  : never;\n\nBy using MyAwaited recursively, we can eventually get the type inside.\nSummary👉 infer can only be used in conditional type.More info on\nhttps://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html\nhttps://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#type-inference-in-conditional-types\n","categories":["Front-end"],"tags":["Typescript","Javascript"]}]